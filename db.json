{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"src/images/components.png","path":"images/components.png","modified":1,"renderable":0},{"_id":"src/images/data.png","path":"images/data.png","modified":1,"renderable":0},{"_id":"src/images/mvvm.png","path":"images/mvvm.png","modified":1,"renderable":0},{"_id":"src/images/state.png","path":"images/state.png","modified":1,"renderable":0},{"_id":"src/images/props-events.png","path":"images/props-events.png","modified":1,"renderable":0},{"_id":"src/images/hn-architecture.png","path":"images/hn-architecture.png","modified":1,"renderable":0},{"_id":"src/images/hn.png","path":"images/hn.png","modified":1,"renderable":0},{"_id":"src/images/lifecycle.png","path":"images/lifecycle.png","modified":1,"renderable":0},{"_id":"src/images/vue-component.png","path":"images/vue-component.png","modified":1,"renderable":0},{"_id":"themes/vue/source/css/benchmark.styl","path":"css/benchmark.styl","modified":1,"renderable":1},{"_id":"themes/vue/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/vue/source/css/page.styl","path":"css/page.styl","modified":1,"renderable":1},{"_id":"themes/vue/source/css/search.styl","path":"css/search.styl","modified":1,"renderable":1},{"_id":"themes/vue/source/images/2mhost.png","path":"images/2mhost.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/actualize.png","path":"images/actualize.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/chaitin.png","path":"images/chaitin.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/check.png","path":"images/check.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/down.png","path":"images/down.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/feed.png","path":"images/feed.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/htmlburger.png","path":"images/htmlburger.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/icons.png","path":"images/icons.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/itunescn.png","path":"images/itunescn.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/jsfiddle.png","path":"images/jsfiddle.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/juejin.png","path":"images/juejin.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/laravel.png","path":"images/laravel.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/logo.png","path":"images/logo.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/menu.png","path":"images/menu.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/monterail.png","path":"images/monterail.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/patreon.png","path":"images/patreon.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/paypal.png","path":"images/paypal.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/search.png","path":"images/search.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/someline.png","path":"images/someline.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/strikingly.png","path":"images/strikingly.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/tde.png","path":"images/tde.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/transition.png","path":"images/transition.png","modified":1,"renderable":1},{"_id":"themes/vue/source/images/trisoft.png","path":"images/trisoft.png","modified":1,"renderable":1},{"_id":"themes/vue/source/js/common.js","path":"js/common.js","modified":1,"renderable":1},{"_id":"themes/vue/source/js/smooth-scroll.min.js","path":"js/smooth-scroll.min.js","modified":1,"renderable":1},{"_id":"themes/vue/source/images/vuejobs.png","path":"images/vuejobs.png","modified":1,"renderable":1},{"_id":"src/images/vue-component-with-preprocessors.png","path":"images/vue-component-with-preprocessors.png","modified":1,"renderable":0},{"_id":"themes/vue/source/js/vue.min.js","path":"js/vue.min.js","modified":1,"renderable":1},{"_id":"themes/vue/source/js/vue.js","path":"js/vue.js","modified":1,"renderable":1}],"Cache":[{"_id":"src/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1478557352000},{"_id":"src/index.md","hash":"fd945de1e31344f0d8be59bcc87e3f5fda468e11","modified":1478519250000},{"_id":"themes/vue/_config.yml","hash":"70c81d659ef7951ce779693c358673364179466f","modified":1478557571000},{"_id":"src/_posts/.DS_Store","hash":"91a577317a3798f2757b472393b1522d646dc4be","modified":1478557375000},{"_id":"src/_posts/1.0.0-release.md","hash":"b950805d513f9bab95e81d02086a423ea84580d0","modified":1478557410000},{"_id":"src/docs/index.md","hash":"5a7644a3784a91b2684c9aa96d981f18829e5906","modified":1478557431000},{"_id":"src/images/components.png","hash":"d4ce2f1000b166e119ea6541c78b3e31106f1fe8","modified":1478519250000},{"_id":"src/images/data.png","hash":"9279fe7689eed01474d5abee0fc39ee5b003cc5a","modified":1478519250000},{"_id":"src/images/mvvm.png","hash":"52c8a6529e7ed652041a6d71f1824db3991ea574","modified":1478519250000},{"_id":"src/images/state.png","hash":"cab62293b1c242683dc7752b8908844792e2252b","modified":1478519250000},{"_id":"src/images/props-events.png","hash":"9e25599114cd5ec4696f24ab631d690beac34137","modified":1478519250000},{"_id":"themes/vue/layout/index.ejs","hash":"2914ab572754c608e6d9f69be1dcb1ccb38779d5","modified":1478557456000},{"_id":"themes/vue/layout/layout.ejs","hash":"4fef308abf52a45a03a1e49f58008e4e7308850c","modified":1478555560000},{"_id":"themes/vue/layout/page.ejs","hash":"85c8b7f10a807d5d88468affaed331654a534ee3","modified":1478555665000},{"_id":"themes/vue/layout/post.ejs","hash":"aa03915a3540de78cfe8fe1c8f9e897974bf35a0","modified":1478519250000},{"_id":"src/images/hn-architecture.png","hash":"f583a2c31083afbeb0f5edb93213426e7c6c41ba","modified":1478519250000},{"_id":"src/images/hn.png","hash":"9e1332008b342502aea641dbfb7d7911d7a03df1","modified":1478519250000},{"_id":"src/images/lifecycle.png","hash":"245ed3bc3f4a0e1698faf640863a1271a3e8ad35","modified":1478519250000},{"_id":"themes/vue/layout/partials/header.ejs","hash":"349218c217c361b187174d87f2a6891792d11618","modified":1478555397000},{"_id":"src/images/vue-component.png","hash":"c14948034d574d0cf1d24f848e4ad9f4f27271a0","modified":1478519250000},{"_id":"themes/vue/layout/partials/main_menu.ejs","hash":"0212467e84beda3d583d6226bd92841a8e67a4a3","modified":1478554956000},{"_id":"themes/vue/layout/partials/sidebar.ejs","hash":"b25e2fcb4dc5f59308f972aecf05bb75d31ca57b","modified":1478555272000},{"_id":"themes/vue/source/css/_common.styl","hash":"6c9802a1021471866d177dd675c0c3b0df222411","modified":1478519250000},{"_id":"themes/vue/source/css/_header.styl","hash":"58deb9f0183b0470dbb68a147e1ef344fa8a682e","modified":1478519250000},{"_id":"themes/vue/source/css/_demo.styl","hash":"495a6bd1418e4fed5e2bf4be08046f054a39b2cf","modified":1478519250000},{"_id":"themes/vue/source/css/_migration.styl","hash":"5ea4f20818827c0d57a36a3006b736366c3b446f","modified":1478519250000},{"_id":"themes/vue/source/css/_settings.styl","hash":"c25843e8e63122df3f37f7583832ac577079d84b","modified":1478519250000},{"_id":"themes/vue/source/css/_sidebar.styl","hash":"5f716a46a1655b8cc6eb10c51d14a8993e53c0c7","modified":1478555197000},{"_id":"themes/vue/source/css/_sponsor.styl","hash":"6a4e1503b1e4f0e98e1e008ba846036fee3199aa","modified":1478519250000},{"_id":"themes/vue/source/css/_syntax.styl","hash":"edb004001fe151bebfdf63bbc250ba75777b5468","modified":1478519250000},{"_id":"themes/vue/source/css/benchmark.styl","hash":"95d4607b2b59623a673e131e1a267d0311fe89e6","modified":1478519250000},{"_id":"themes/vue/source/css/index.styl","hash":"0e7d5b0d0a07a4ada74072c8d471c16c121a59c0","modified":1478519250000},{"_id":"themes/vue/source/css/page.styl","hash":"06e37bc5a4a94c8a55f8533c84d9018d32afe58e","modified":1478555194000},{"_id":"themes/vue/source/css/search.styl","hash":"5117f05598154cfc84da04ec1a257bd186653ba2","modified":1478519250000},{"_id":"themes/vue/source/images/2mhost.png","hash":"a42a475ec7d2b36e82f420bd80a9957915dab2ce","modified":1478519250000},{"_id":"themes/vue/source/images/actualize.png","hash":"7b9c0fefb69cc4fad0520782f5445d495975bb57","modified":1478519250000},{"_id":"themes/vue/source/images/chaitin.png","hash":"0cca04b4c318b04be96ed066bc6ad3bb5f3788ec","modified":1478519250000},{"_id":"themes/vue/source/images/check.png","hash":"682cf89e1802afb1dfddf07a6aed828a45b824af","modified":1478519250000},{"_id":"themes/vue/source/images/down.png","hash":"42505e12d686cf580f793bd9193acbac1e3e3a91","modified":1478519250000},{"_id":"themes/vue/source/images/feed.png","hash":"0a746dab71dca2025f63584dbd222dc5e0707ba8","modified":1478519250000},{"_id":"themes/vue/source/images/htmlburger.png","hash":"0005ef9559a88da3ff7b30b53e44acc5f1a14e46","modified":1478519250000},{"_id":"themes/vue/source/images/icons.png","hash":"91225ef7011e59dbe6b4b9f2666133fb5e1bc976","modified":1478519250000},{"_id":"themes/vue/source/images/itunescn.png","hash":"75968c5e469bec3d061c9207ca872b2e57081015","modified":1478519250000},{"_id":"themes/vue/source/images/jsfiddle.png","hash":"0646dceea2a62d3f5d2aabff4bdecffdf54cc8a7","modified":1478519250000},{"_id":"themes/vue/source/images/juejin.png","hash":"a346d9068f1e4f65262fdc885c5fb362ea3f36b8","modified":1478519250000},{"_id":"themes/vue/source/images/laravel.png","hash":"d49fdacbae388601d2ff339b31aedd3c0dd3be3a","modified":1478519250000},{"_id":"themes/vue/source/images/logo.png","hash":"a3adcce57e12725df16ebaecc313e1991b30bb68","modified":1478519250000},{"_id":"themes/vue/source/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1478519250000},{"_id":"themes/vue/source/images/monterail.png","hash":"17b3a1f12f5c40b7b94ce320cc2ec9a4df9bca5e","modified":1478519250000},{"_id":"themes/vue/source/images/patreon.png","hash":"c2455d5a6a59ff2b0ce5d698a74af7ed7226438c","modified":1478519250000},{"_id":"themes/vue/source/images/paypal.png","hash":"4db177273d209e621a99941d6457456a0950eb96","modified":1478519250000},{"_id":"themes/vue/source/images/search.png","hash":"12d664cc51b8d53c9214830bc9b92fb340526a7b","modified":1478519250000},{"_id":"themes/vue/source/images/someline.png","hash":"81ee000201cb80b19c7d79cc116c688c34163d36","modified":1478519250000},{"_id":"themes/vue/source/images/strikingly.png","hash":"d16ea35e0693928823b99efafc139f1ea1d6cb90","modified":1478519250000},{"_id":"themes/vue/source/images/tde.png","hash":"ffa3a10004c2510cabd23ba99bdcb5012aab3835","modified":1478519250000},{"_id":"themes/vue/source/images/transition.png","hash":"47b92628ea1263d651dab90093ff5682d2e54e68","modified":1478519250000},{"_id":"themes/vue/source/images/trisoft.png","hash":"c5689ce6833a3696406dc73bb50fa5b6b18b2dbe","modified":1478519250000},{"_id":"themes/vue/source/js/common.js","hash":"f8753cf3eaf454e4555afb5b9181e5852796164b","modified":1478558086000},{"_id":"themes/vue/source/js/smooth-scroll.min.js","hash":"86d3196a003a5cdc673a4c6ebb75db3ceee1a1a7","modified":1478519250000},{"_id":"themes/vue/source/images/vuejobs.png","hash":"25aa2ef77fcb62051036171942f3575af2a12e9c","modified":1478519250000},{"_id":"src/images/vue-component-with-preprocessors.png","hash":"9dfddb18d5f34cbeadf6e94b4559f932dbc0f573","modified":1478519250000},{"_id":"themes/vue/source/js/vue.min.js","hash":"cb9b2c5b752e244b755b0e624a6b5533db609daa","modified":1478519250000},{"_id":"themes/vue/source/js/vue.js","hash":"e54ade87b0183c9c16bcdd390bfffe29515662c0","modified":1478519250000}],"Category":[],"Data":[],"Page":[{"index":true,"_content":"","source":"index.md","raw":"index: true\n---\n","date":"2016-11-07T20:41:56.000Z","updated":"2016-11-07T11:47:30.000Z","path":"index.html","title":"","comments":1,"layout":"page","_id":"civ8ndoyv0000wqm1hgmnlbj5","content":"","excerpt":"","more":""},{"type":"docs","_content":"\n## Introduction\n\n**Zman** is a PHP package that makes Jewish date conversions simple and easy.\n\nThe `Zman` class is inherited from the amazing [briannesbitt/Carbon](https://github.com/briannesbitt/Carbon) which in turn inherits from PHP's [DateTime](http://www.php.net/manual/en/class.datetime.php) class, thus giving us access to some pretty nifty methods.\n\n## Instantiation\n\nThere are three different ways to create a new instance of `Zman`.\n\n```PHP\n$zman = new Zman('first day of November 2016');\n$zman = Zman::parse('first day of November 2016');\n$zman = Zman::now();\n```\n<!-- \n\n### silent\n\n- **Type:** `boolean`\n\n- **Default:** `false`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.silent = true\n  ```\n\n  Suppress all Vue logs and warnings.\n\n### optionMergeStrategies\n\n- **Type:** `{ [key: string]: Function }`\n\n- **Default:** `{}`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {\n    return child + 1\n  }\n\n  const Profile = Vue.extend({\n    _my_option: 1\n  })\n\n  // Profile.options._my_option = 2\n  ```\n\n  Define custom merging strategies for options.\n\n  The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument.\n\n- **See also:** [Custom Option Merging Strategies](../guide/mixins.html#Custom-Option-Merge-Strategies)\n\n### devtools\n\n- **Type:** `boolean`\n\n- **Default:** `true` (`false` in production builds)\n\n- **Usage:**\n\n  ``` js\n  // make sure to set this synchronously immediately after loading Vue\n  Vue.config.devtools = true\n  ```\n\n  Configure whether to allow [vue-devtools](https://github.com/vuejs/vue-devtools) inspection. This option's default value is `true` in development builds and `false` in production builds. You can set it to `true` to enable inspection for production builds.\n\n### errorHandler\n\n- **Type:** `Function`\n\n- **Default:** Error is thrown in place\n\n- **Usage:**\n\n  ``` js\n  Vue.config.errorHandler = function (err, vm) {\n    // handle error\n  }\n  ```\n\n  Assign a handler for uncaught errors during component render and watchers. The handler gets called with the error and the Vue instance.\n\n  > [Sentry](https://sentry.io), an error tracking service, provides [official integration](https://sentry.io/for/vue/) using this option.\n\n### ignoredElements\n\n- **Type:** `Array<string>`\n\n- **Default:** `[]`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.ignoredElements = [\n    'my-custom-web-component', 'another-web-component'\n  ]\n  ```\n\n  Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an `Unknown custom element`, assuming that you forgot to register a global component or misspelled a component name.\n\n### keyCodes\n\n- **Type:** `{ [key: string]: number }`\n\n- **Default:** `{}`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.keyCodes = {\n    v: 86,\n    f1: 112,\n    mediaPlayPause: 179\n  }\n  ```\n\n  Define custom key alias(es) for v-on.\n\n## Global API\n\n<h3 id=\"Vue-extend\">Vue.extend( options )</h3>\n\n- **Arguments:**\n  - `{Object} options`\n\n- **Usage:**\n\n  Create a \"subclass\" of the base Vue constructor. The argument should be an object containing component options.\n\n  The special case to note here is the `data` option - it must be a function when used with `Vue.extend()`.\n\n  ``` html\n  <div id=\"mount-point\"></div>\n  ```\n\n  ``` js\n  // create constructor\n  var Profile = Vue.extend({\n    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',\n    data: function () {\n      return {\n        firstName: 'Walter',\n        lastName: 'White',\n        alias: 'Heisenberg'\n      }\n    }\n  })\n  // create an instance of Profile and mount it on an element\n  new Profile().$mount('#mount-point')\n  ```\n\n  Will result in:\n\n  ``` html\n  <p>Walter White aka Heisenberg</p>\n  ```\n\n- **See also:** [Components](../guide/components.html)\n\n<h3 id=\"Vue-nextTick\">Vue.nextTick( callback, [context] )</h3>\n\n- **Arguments:**\n  - `{Function} callback`\n  - `{Object} [context]`\n\n- **Usage:**\n\n  Defer the callback to be executed after the next DOM update cycle. Use it immediately after you've changed some data to wait for the DOM update.\n\n  ``` js\n  // modify data\n  vm.msg = 'Hello'\n  // DOM not updated yet\n  Vue.nextTick(function () {\n    // DOM updated\n  })\n  ```\n\n- **See also:** [Async Update Queue](../guide/reactivity.html#Async-Update-Queue)\n\n<h3 id=\"Vue-set\">Vue.set( object, key, value )</h3>\n\n- **Arguments:**\n  - `{Object} object`\n  - `{string} key`\n  - `{any} value`\n\n- **Returns:** the set value.\n\n- **Usage:**\n\n  Set a property on an object. If the object is reactive, ensure the property is created as a reactive property and trigger view updates. This is primarily used to get around the limitation that Vue cannot detect property additions.\n\n  **Note the object cannot be a Vue instance, or the root data object of a Vue instance.**\n\n- **See also:** [Reactivity in Depth](../guide/reactivity.html)\n\n<h3 id=\"Vue-delete\">Vue.delete( object, key )</h3>\n\n- **Arguments:**\n  - `{Object} object`\n  - `{string} key`\n\n- **Usage:**\n\n  Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates. This is primarily used to get around the limitation that Vue cannot detect property deletions, but you should rarely need to use it.\n\n  **Note the object cannot be a Vue instance, or the root data object of a Vue instance.**\n\n- **See also:** [Reactivity in Depth](../guide/reactivity.html)\n\n<h3 id=\"Vue-directive\">Vue.directive( id, [definition] )</h3>\n\n- **Arguments:**\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **Usage:**\n\n  Register or retrieve a global directive.\n\n  ``` js\n  // register\n  Vue.directive('my-directive', {\n    bind: function () {},\n    inserted: function () {},\n    update: function () {},\n    componentUpdated: function () {},\n    unbind: function () {}\n  })\n\n  // register (simple function directive)\n  Vue.directive('my-directive', function () {\n    // this will be called as `bind` and `update`\n  })\n\n  // getter, return the directive definition if registered\n  var myDirective = Vue.directive('my-directive')\n  ```\n\n- **See also:** [Custom Directives](../guide/custom-directive.html)\n\n<h3 id=\"Vue-filter\">Vue.filter( id, [definition] )</h3>\n\n- **Arguments:**\n  - `{string} id`\n  - `{Function} [definition]`\n\n- **Usage:**\n\n  Register or retrieve a global filter.\n\n  ``` js\n  // register\n  Vue.filter('my-filter', function (value) {\n    // return processed value\n  })\n\n  // getter, return the filter if registered\n  var myFilter = Vue.filter('my-filter')\n  ```\n\n<h3 id=\"Vue-component\">Vue.component( id, [definition] )</h3>\n\n- **Arguments:**\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **Usage:**\n\n  Register or retrieve a global component. Registration also automatically sets the component's `name` with the given `id`.\n\n  ``` js\n  // register an extended constructor\n  Vue.component('my-component', Vue.extend({ /* ... */ }))\n\n  // register an options object (automatically call Vue.extend)\n  Vue.component('my-component', { /* ... */ })\n\n  // retrieve a registered component (always return constructor)\n  var MyComponent = Vue.component('my-component')\n  ```\n\n- **See also:** [Components](../guide/components.html)\n\n<h3 id=\"Vue-use\">Vue.use( plugin )</h3>\n\n- **Arguments:**\n  - `{Object | Function} plugin`\n\n- **Usage:**\n\n  Install a Vue.js plugin. If the plugin is an Object, it must expose an `install` method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.\n\n  When this method is called on the same plugin multiple times, the plugin will be installed only once.\n\n- **See also:** [Plugins](../guide/plugins.html)\n\n<h3 id=\"Vue-mixin\">Vue.mixin( mixin )</h3>\n\n- **Arguments:**\n  - `{Object} mixin`\n\n- **Usage:**\n\n  Apply a mixin globally, which affects every Vue instance created afterwards. This can be used by plugin authors to inject custom behavior into components. **Not recommended in application code**.\n\n- **See also:** [Global Mixins](../guide/mixins.html#Global-Mixin)\n\n<h3 id=\"Vue-compile\">Vue.compile( template )</h3>\n\n- **Arguments:**\n  - `{string} template`\n\n- **Usage:**\n\n  Compiles a template string into a render function. **Only available in the standalone build.**\n\n  ``` js\n  var res = Vue.compile('<div><span>{{ msg }}</span></div>')\n\n  new Vue({\n    data: {\n      msg: 'hello'\n    },\n    render: res.render,\n    staticRenderFns: res.staticRenderFns\n  })\n  ```\n\n- **See also:** [Render Functions](../guide/render-function.html)\n\n## Options / Data\n\n### data\n\n- **Type:** `Object | Function`\n\n- **Restriction:** Only accepts `Function` when used in a component definition.\n\n- **Details:**\n\n  The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it \"reactive\". **The object must be plain**: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with its own stateful behavior.\n\n  Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.\n\n  After the instance is created, the original data object can be accessed as `vm.$data`. The Vue instance also proxies all the properties found on the data object, so `vm.a` will be equivalent to `vm.$data.a`.\n\n  Properties that start with `_` or `$` will **not** be proxied on the Vue instance because they may conflict with Vue's internal properties and API methods. You will have to access them as `vm.$data._property`.\n\n  When defining a **component**, `data` must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we still use a plain object for `data`, that same object will be **shared by reference** across all instances created! By providing a `data` function, every time a new instance is created, we can simply call it to return a fresh copy of the initial data.\n\n  If required, a deep clone of the original object can be obtained by passing `vm.$data` through `JSON.parse(JSON.stringify(...))`.\n\n- **Example:**\n\n  ``` js\n  var data = { a: 1 }\n\n  // direct instance creation\n  var vm = new Vue({\n    data: data\n  })\n  vm.a // -> 1\n  vm.$data === data // -> true\n\n  // must use function when in Vue.extend()\n  var Component = Vue.extend({\n    data: function () {\n      return { a: 1 }\n    }\n  })\n  ```\n\n  <p class=\"tip\">Note that __you should not use an arrow function with the `data` property__ (e.g. `data: () => { return { a: this.myProp }}`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.myProp` will be undefined.</p>\n\n- **See also:** [Reactivity in Depth](../guide/reactivity.html)\n\n### props\n\n- **Type:** `Array<string> | Object`\n\n- **Details:**\n\n  A list/hash of attributes that are exposed to accept data from the parent component. It has a simple Array-based syntax and an alternative Object-based syntax that allows advanced configurations such as type checking, custom validation and default values.\n\n- **Example:**\n\n  ``` js\n  // simple syntax\n  Vue.component('props-demo-simple', {\n    props: ['size', 'myMessage']\n  })\n\n  // object syntax with validation\n  Vue.component('props-demo-advanced', {\n    props: {\n      // just type check\n      height: Number,\n      // type check plus other validations\n      age: {\n        type: Number,\n        default: 0,\n        required: true,\n        validator: function (value) {\n          return value >= 0\n        }\n      }\n    }\n  })\n  ```\n\n- **See also:** [Props](../guide/components.html#Props)\n\n### propsData\n\n- **Type:** `{ [key: string]: any }`\n\n- **Restriction:** only respected in instance creation via `new`.\n\n- **Details:**\n\n  Pass props to an instance during its creation. This is primarily intended to make unit testing easier.\n\n- **Example:**\n\n  ``` js\n  var Comp = Vue.extend({\n    props: ['msg'],\n    template: '<div>{{ msg }}</div>'\n  })\n\n  var vm = new Comp({\n    propsData: {\n      msg: 'hello'\n    }\n  })\n  ```\n\n### computed\n\n- **Type:** `{ [key: string]: Function | { get: Function, set: Function } }`\n\n- **Details:**\n\n  Computed properties to be mixed into the Vue instance. All getters and setters have their `this` context automatically bound to the Vue instance.\n\n  <p class=\"tip\">Note that __you should not use an arrow function to define a computed property__ (e.g. `aDouble: () => this.a * 2`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.a` will be undefined.</p>\n\n  Computed properties are cached, and only re-computed on reactive dependency changes.\n\n- **Example:**\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    computed: {\n      // get only, just need a function\n      aDouble: function () {\n        return this.a * 2\n      },\n      // both get and set\n      aPlus: {\n        get: function () {\n          return this.a + 1\n        },\n        set: function (v) {\n          this.a = v - 1\n        }\n      }\n    }\n  })\n  vm.aPlus   // -> 2\n  vm.aPlus = 3\n  vm.a       // -> 2\n  vm.aDouble // -> 4\n  ```\n\n- **See also:**\n  - [Computed Properties](../guide/computed.html)\n\n### methods\n\n- **Type:** `{ [key: string]: Function }`\n\n- **Details:**\n\n  Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their `this` context automatically bound to the Vue instance.\n\n  <p class=\"tip\">Note that __you should not use an arrow function to define a method__ (e.g. `plus: () => this.a++`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.a` will be undefined.</p>\n\n- **Example:**\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    methods: {\n      plus: function () {\n        this.a++\n      }\n    }\n  })\n  vm.plus()\n  vm.a // 2\n  ```\n\n- **See also:** [Methods and Event Handling](../guide/events.html)\n\n### watch\n\n- **Type:** `{ [key: string]: string | Function | Object }`\n\n- **Details:**\n\n  An object where keys are expressions to watch and values are the corresponding callbacks. The value can also be a string of a method name, or an Object that contains additional options. The Vue instance will call `$watch()` for each entry in the object at instantiation.\n\n- **Example:**\n\n  ``` js\n  var vm = new Vue({\n    data: {\n      a: 1,\n      b: 2,\n      c: 3\n    },\n    watch: {\n      a: function (val, oldVal) {\n        console.log('new: %s, old: %s', val, oldVal)\n      },\n      // string method name\n      b: 'someMethod',\n      // deep watcher\n      c: {\n        handler: function (val, oldVal) { /* ... */ },\n        deep: true\n      }\n    }\n  })\n  vm.a = 2 // -> new: 2, old: 1\n  ```\n\n  <p class=\"tip\">Note that __you should not use an arrow function to define a watcher__ (e.g. `searchQuery: newValue => this.updateAutocomplete(newValue)`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.updateAutocomplete` will be undefined.</p>\n\n- **See also:** [Instance Methods - vm.$watch](#vm-watch)\n\n## Options / DOM\n\n### el\n\n- **Type:** `string | HTMLElement`\n\n- **Restriction:** only respected in instance creation via `new`.\n\n- **Details:**\n\n  Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.\n\n  After the instance is mounted, the resolved element will be accessible as `vm.$el`.\n\n  If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call `vm.$mount()` to manually start the compilation.\n\n  <p class=\"tip\">The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to `<html>` or `<body>`.</p>\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### template\n\n- **Type:** `string`\n\n- **Details:**\n\n  A string template to be used as the markup for the Vue instance. The template will **replace** the mounted element. Any existing markup inside the mounted element will be ignored, unless content distribution slots are present in the template.\n\n  If the string starts with `#` it will be used as a querySelector and use the selected element's innerHTML as the template string. This allows the use of the common `<script type=\"x-template\">` trick to include templates.\n\n  <p class=\"tip\">From a security perspective, you should only use Vue templates that you can trust. Never use user-generated content as your template.</p>\n\n- **See also:**\n  - [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n  - [Content Distribution](../guide/components.html#Content-Distribution-with-Slots)\n\n### render\n\n  - **Type:** `Function`\n\n  - **Details:**\n\n    An alternative to string templates allowing you to leverage the full programmatic power of JavaScript. The render function receives a `createElement` method as it's first argument used to create `VNode`s.\n\n    If the component is a functional component, the render function also receives an extra argument `context`, which provides access to contextual data since functional components are instance-less.\n\n  - **See also:**\n    - [Render Functions](../guide/render-function)\n\n## Options / Lifecycle Hooks\n\nAll lifecycle hooks automatically have their `this` context bound to the instance, so that you can access data, computed properties, and methods. This means __you should not use an arrow function to define a lifecycle method__ (e.g. `created: () => this.fetchTodos()`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.fetchTodos` will be undefined.\n\n### beforeCreate\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called synchronously after the instance has just been initialized, before data observation and event/watcher setup.\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### created\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called synchronously after the instance is created. At this stage, the instance has finished processing the options which means the following have been set up: data observation, computed properties, methods, watch/event callbacks. However, the mounting phase has not been started, and the `$el` property will not be available yet.\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### beforeMount\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called right before the mounting begins: the `render` function is about to be called for the first time.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### mounted\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called after the instance has just been mounted where `el` is replaced by the newly created `vm.$el`. If the root instance is mounted to an in-document element, `vm.$el` will also be in-document when `mounted` is called.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### beforeUpdate\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called when the data changes, before the virtual DOM is re-rendered and patched.\n\n  You can perform further state changes in this hook and they will not trigger additional re-renders.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### updated\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called after a data change causes the virtual DOM to be re-rendered and patched.\n\n  The component's DOM will be in updated state when this hook is called, so you can perform DOM-dependent operations in this hook. However, in most cases you should avoid changing state in this hook, because it may lead to an infinite update loop.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### activated\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called when a kept-alive component is activated.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:**\n  - [Built-in Components - keep-alive](#keep-alive)\n  - [Dynamic Components - keep-alive](../guide/components.html#keep-alive)\n\n### deactivated\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called when a kept-alive component is deactivated.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:**\n  - [Built-in Components - keep-alive](#keep-alive)\n  - [Dynamic Components - keep-alive](../guide/components.html#keep-alive)\n\n### beforeDestroy\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called right before a Vue instance is destroyed. At this stage the instance is still fully functional.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### destroyed\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called after a Vue instance has been destroyed. When this hook is called, all directives of the Vue instance have been unbound, all event listeners have been removed, and all child Vue instances have also been destroyed.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n## Options / Assets\n\n### directives\n\n- **Type:** `Object`\n\n- **Details:**\n\n  A hash of directives to be made available to the Vue instance.\n\n- **See also:**\n  - [Custom Directives](../guide/custom-directive.html)\n  - [Assets Naming Convention](../guide/components.html#Assets-Naming-Convention)\n\n### filters\n\n- **Type:** `Object`\n\n- **Details:**\n\n  A hash of filters to be made available to the Vue instance.\n\n- **See also:**\n  - [`Vue.filter`](#Vue-filter)\n\n### components\n\n- **Type:** `Object`\n\n- **Details:**\n\n  A hash of components to be made available to the Vue instance.\n\n- **See also:**\n  - [Components](../guide/components.html)\n\n## Options / Misc\n\n### parent\n\n- **Type:** `Vue instance`\n\n- **Details:**\n\n  Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as `this.$parent` for the child, and the child will be pushed into the parent's `$children` array.\n\n  <p class=\"tip\">Use `$parent` and `$children` sparringly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</p>\n\n### mixins\n\n- **Type:** `Array<Object>`\n\n- **Details:**\n\n  The `mixins` option accepts an array of mixin objects. These mixin objects can contain instance options just like normal instance objects, and they will be merged against the eventual options using the same option merging logic in `Vue.extend()`. e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called.\n\n  Mixin hooks are called in the order they are provided, and called before the component's own hooks.\n\n- **Example:**\n\n  ``` js\n  var mixin = {\n    created: function () { console.log(1) }\n  }\n  var vm = new Vue({\n    created: function () { console.log(2) },\n    mixins: [mixin]\n  })\n  // -> 1\n  // -> 2\n  ```\n\n- **See also:** [Mixins](../guide/mixins.html)\n\n### name\n\n- **Type:** `string`\n\n- **Restriction:** only respected when used as a component option.\n\n- **Details:**\n\n  Allow the component to recursively invoke itself in its template. Note that when a component is registered globally with `Vue.component()`, the global ID is automatically set as its name.\n\n  Another benefit of specifying a `name` option is debugging. Named components result in more helpful warning messages. Also, when inspecting an app in the [vue-devtools](https://github.com/vuejs/vue-devtools), unnamed components will show up as `<AnonymousComponent>`, which isn't very informative. By providing the `name` option, you will get a much more informative component tree.\n\n### extends\n\n- **Type:** `Object | Function`\n\n- **Details:**\n\n  Allows declaratively extending another component (could be either a plain options object or a constructor) without having to use `Vue.extend`. This is primarily intended to make it easier to extend between single file components.\n\n  This is similar to `mixins`, the difference being that the component's own options takes higher priority than the source component being extended.\n\n- **Example:**\n\n  ``` js\n  var CompA = { ... }\n\n  // extend CompA without having to call Vue.extend on either\n  var CompB = {\n    extends: CompA,\n    ...\n  }\n  ```\n\n### delimiters\n\n- **Type:** `Array<string>`\n\n- **default:** `{% raw %}[\"{{\", \"}}\"]{% endraw %}`\n\n- **Details:**\n\n  Change the plain text interpolation delimiters. **This option is only available in the standalone build.**\n\n- **Example:**\n\n  ``` js\n  new Vue({\n    delimiters: ['${', '}']\n  })\n\n  // Delimiters changed to ES6 template string style\n  ```\n\n### functional\n\n- **Type:** `boolean`\n\n- **Details:**\n\n  Causes a component to be stateless (no `data`) and instanceless (no `this` context). They are simply a `render` function that returns virtual nodes making them much cheaper to render.\n\n- **See also:** [Functional Components](../guide/render-function.html#Functional-Components)\n\n## Instance Properties\n\n### vm.$data\n\n- **Type:** `Object`\n\n- **Details:**\n\n  The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object.\n\n- **See also:** [Options - data](#data)\n\n### vm.$el\n\n- **Type:** `HTMLElement`\n\n- **Read only**\n\n- **Details:**\n\n  The root DOM element that the Vue instance is managing.\n\n### vm.$options\n\n- **Type:** `Object`\n\n- **Read only**\n\n- **Details:**\n\n  The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options:\n\n  ``` js\n  new Vue({\n    customOption: 'foo',\n    created: function () {\n      console.log(this.$options.customOption) // -> 'foo'\n    }\n  })\n  ```\n\n### vm.$parent\n\n- **Type:** `Vue instance`\n\n- **Read only**\n\n- **Details:**\n\n  The parent instance, if the current instance has one.\n\n### vm.$root\n\n- **Type:** `Vue instance`\n\n- **Read only**\n\n- **Details:**\n\n  The root Vue instance of the current component tree. If the current instance has no parents this value will be itself.\n\n### vm.$children\n\n- **Type:** `Array<Vue instance>`\n\n- **Read only**\n\n- **Details:**\n\n  The direct child components of the current instance. **Note there's no order guarantee for `$children`, and it is not reactive.** If you find yourself trying to use `$children` for data binding, consider using an Array and `v-for` to generate child components, and use the Array as the source of truth.\n\n### vm.$slots\n\n- **Type:** `Object`\n\n- **Read only**\n\n- **Details:**\n\n  Used to access content [distributed by slots](../guide/components.html#Content-Distribution-with-Slots). Each [named slot](../guide/components.html#Named-Slots) has its own corresponding property (e.g. the contents of `slot=\"foo\"` will be found at `vm.$slots.foo`). The `default` property contains any nodes not included in a named slot.\n\n  Accessing `vm.$slots` is most useful when writing a component with a [render function](../guide/render-function.html).\n\n- **Example:**\n\n  ```html\n  <blog-post>\n    <h1 slot=\"header\">\n      About Me\n    </h1>\n\n    <p>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.</p>\n\n    <p slot=\"footer\">\n      Copyright 2016 Evan You\n    </p>\n\n    <p>If I have some content down here, it will also be included in vm.$slots.default.</p>.\n  </blog-post>\n  ```\n\n  ```js\n  Vue.component('blog-post', {\n    render: function (createElement) {\n      var header = this.$slots.header\n      var body   = this.$slots.default\n      var footer = this.$slots.footer\n      return createElement('div', [\n        createElement('header', header)\n        createElement('main', body)\n        createElement('footer', footer)\n      ])\n    }\n  })\n  ```\n\n- **See also:**\n  - [`<slot>` Component](#slot)\n  - [Content Distribution with Slots](../guide/components.html#Content-Distribution-with-Slots)\n  - [Render Functions](../guide/render-function.html)\n\n### vm.$refs\n\n- **Type:** `Object`\n\n- **Read only**\n\n- **Details:**\n\n  An object that holds child components that have `ref` registered.\n\n- **See also:**\n  - [Child Component Refs](../guide/components.html#Child-Component-Refs)\n  - [ref](#ref)\n\n### vm.$isServer\n\n- **Type:** `boolean`\n\n- **Read only**\n\n- **Details:**\n\n  Whether the current Vue instance is running on the server.\n\n- **See also:** [Server-Side Rendering](../guide/ssr.html)\n\n## Instance Methods / Data\n\n<h3 id=\"vm-watch\">vm.$watch( expOrFn, callback, [options] )</h3>\n\n- **Arguments:**\n  - `{string | Function} expOrFn`\n  - `{Function} callback`\n  - `{Object} [options]`\n    - `{boolean} deep`\n    - `{boolean} immediate`\n\n- **Returns:** `{Function} unwatch`\n\n- **Usage:**\n\n  Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts simple dot-delimited paths. For more complex expression, use a function instead.\n\n<p class=\"tip\">Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn't keep a copy of the pre-mutate value.</p>\n\n- **Example:**\n\n  ``` js\n  // keypath\n  vm.$watch('a.b.c', function (newVal, oldVal) {\n    // do something\n  })\n\n  // function\n  vm.$watch(\n    function () {\n      return this.a + this.b\n    },\n    function (newVal, oldVal) {\n      // do something\n    }\n  )\n  ```\n\n  `vm.$watch` returns an unwatch function that stops firing the callback:\n\n  ``` js\n  var unwatch = vm.$watch('a', cb)\n  // later, teardown the watcher\n  unwatch()\n  ```\n\n- **Option: deep**\n\n  To also detect nested value changes inside Objects, you need to pass in `deep: true` in the options argument. Note that you don't need to do so to listen for Array mutations.\n\n  ``` js\n  vm.$watch('someObject', callback, {\n    deep: true\n  })\n  vm.someObject.nestedValue = 123\n  // callback is fired\n  ```\n\n- **Option: immediate**\n\n  Passing in `immediate: true` in the option will trigger the callback immediately with the current value of the expression:\n\n  ``` js\n  vm.$watch('a', callback, {\n    immediate: true\n  })\n  // callback is fired immediately with current value of `a`\n  ```\n\n<h3 id=\"vm-set\">vm.$set( object, key, value )</h3>\n\n- **Arguments:**\n  - `{Object} object`\n  - `{string} key`\n  - `{any} value`\n\n- **Returns:** the set value.\n\n- **Usage:**\n\n  This is the **alias** of the global `Vue.set`.\n\n- **See also:** [Vue.set](#Vue-set)\n\n<h3 id=\"vm-delete\">vm.$delete( object, key )</h3>\n\n- **Arguments:**\n  - `{Object} object`\n  - `{string} key`\n\n- **Usage:**\n\n  This is the **alias** of the global `Vue.delete`.\n\n- **See also:** [Vue.delete](#Vue-delete)\n\n## Instance Methods / Events\n\n<h3 id=\"vm-on\">vm.$on( event, callback )</h3>\n\n- **Arguments:**\n  - `{string} event`\n  - `{Function} callback`\n\n- **Usage:**\n\n  Listen for a custom event on the current vm. Events can be triggered by `vm.$emit`. The callback will receive all the additional arguments passed into these event-triggering methods.\n\n- **Example:**\n\n  ``` js\n  vm.$on('test', function (msg) {\n    console.log(msg)\n  })\n  vm.$emit('test', 'hi')\n  // -> \"hi\"\n  ```\n\n<h3 id=\"vm-once\">vm.$once( event, callback )</h3>\n\n- **Arguments:**\n  - `{string} event`\n  - `{Function} callback`\n\n- **Usage:**\n\n  Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.\n\n<h3 id=\"vm-off\">vm.$off( [event, callback] )</h3>\n\n- **Arguments:**\n  - `{string} [event]`\n  - `{Function} [callback]`\n\n- **Usage:**\n\n  Remove event listener(s).\n\n  - If no arguments are provided, remove all event listeners;\n\n  - If only the event is provided, remove all listeners for that event;\n\n  - If both event and callback are given, remove the listener for that specific callback only.\n\n<h3 id=\"vm-emit\">vm.$emit( event, [...args] )</h3>\n\n- **Arguments:**\n  - `{string} event`\n  - `[...args]`\n\n  Trigger an event on the current instance. Any additional arguments will be passed into the listener's callback function.\n\n## Instance Methods / Lifecycle\n\n<h3 id=\"vm-mount\">vm.$mount( [elementOrSelector] )</h3>\n\n- **Arguments:**\n  - `{Element | string} [elementOrSelector]`\n  - `{boolean} [hydrating]`\n\n- **Returns:** `vm` - the instance itself\n\n- **Usage:**\n\n  If a Vue instance didn't receive the `el` option at instantiation, it will be in \"unmounted\" state, without an associated DOM element. `vm.$mount()` can be used to manually start the mounting of an unmounted Vue instance.\n\n  If `elementOrSelector` argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.\n\n  The method returns the instance itself so you can chain other instance methods after it.\n\n- **Example:**\n\n  ``` js\n  var MyComponent = Vue.extend({\n    template: '<div>Hello!</div>'\n  })\n\n  // create and mount to #app (will replace #app)\n  new MyComponent().$mount('#app')\n\n  // the above is the same as:\n  new MyComponent({ el: '#app' })\n\n  // or, render off-document and append afterwards:\n  var component = new MyComponent().$mount()\n  document.getElementById('app').appendChild(component.$el)\n  ```\n\n- **See also:**\n  - [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n  - [Server-Side Rendering](../guide/ssr.html)\n\n<h3 id=\"vm-forceUpdate\">vm.$forceUpdate()</h3>\n\n- **Usage:**\n\n  Force the Vue instance to re-render. Note it does not affect all child components, only the instance itself and child components with inserted slot content.\n\n<h3 id=\"vm-nextTick\">vm.$nextTick( callback )</h3>\n\n- **Arguments:**\n  - `{Function} callback`\n\n- **Usage:**\n\n  Defer the callback to be executed after the next DOM update cycle. Use it immediately after you've changed some data to wait for the DOM update. This is the same as the global `Vue.nextTick`, except that the callback's `this` context is automatically bound to the instance calling this method.\n\n- **Example:**\n\n  ``` js\n  new Vue({\n    // ...\n    methods: {\n      // ...\n      example: function () {\n        // modify data\n        this.message = 'changed'\n        // DOM is not updated yet\n        this.$nextTick(function () {\n          // DOM is now updated\n          // `this` is bound to the current instance\n          this.doSomethingElse()\n        })\n      }\n    }\n  })\n  ```\n\n- **See also:**\n  - [Vue.nextTick](#Vue-nextTick)\n  - [Async Update Queue](../guide/reactivity.html#Async-Update-Queue)\n\n<h3 id=\"vm-destroy\">vm.$destroy()</h3>\n\n- **Usage:**\n\n  Completely destroy a vm. Clean up its connections with other existing vms, unbind all its directives, turn off all event listeners.\n\n  Triggers the `beforeDestroy` and `destroyed` hooks.\n\n  <p class=\"tip\">In normal use cases you shouldn't have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using `v-if` and `v-for`.</p>\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n## Directives\n\n### v-text\n\n- **Expects:** `string`\n\n- **Details:**\n\n  Updates the element's `textContent`. If you need to update the part of `textContent`, you should use `{% raw %}{{ Mustache }}{% endraw %}` interpolations.\n\n- **Example:**\n\n  ```html\n  <span v-text=\"msg\"></span>\n  <!-- same as -->\n  <span>{{msg}}</span>\n  ```\n\n- **See also:** [Data Binding Syntax - interpolations](../guide/syntax.html#Text)\n\n### v-html\n\n- **Expects:** `string`\n\n- **Details:**\n\n  Updates the element's `innerHTML`. **Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates**. If you find yourself trying to compose templates using `v-html`, try to rethink the solution by using components instead.\n\n  <p class=\"tip\">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to [XSS attacks](https://en.wikipedia.org/wiki/Cross-site_scripting). Only use `v-html` on trusted content and **never** on user-provided content.</p>\n\n- **Example:**\n\n  ```html\n  <div v-html=\"html\"></div>\n  ```\n- **See also:** [Data Binding Syntax - interpolations](../guide/syntax.html#Raw-HTML)\n\n### v-if\n\n- **Expects:** `any`\n\n- **Usage:**\n\n  Conditionally render the element based on the truthy-ness of the expression value. The element and its contained directives / components are destroyed and re-constructed during toggles. If the element is a `<template>` element, its content will be extracted as the conditional block.\n\n  This directive triggers transitions when its condition changes.\n\n- **See also:** [Conditional Rendering - v-if](../guide/conditional.html)\n\n### v-show\n\n- **Expects:** `any`\n\n- **Usage:**\n\n  Toggle's the element's `display` CSS property based on the truthy-ness of the expression value.\n\n  This directive triggers transitions when its condition changes.\n\n- **See also:** [Conditional Rendering - v-show](../guide/conditional.html#v-show)\n\n### v-else\n\n- **Does not expect expression**\n\n- **Restriction:** previous sibling element must have `v-if`.\n\n- **Usage:**\n\n  Denote the \"else block\" for `v-if`.\n\n  ```html\n  <div v-if=\"Math.random() > 0.5\">\n    Now you see me\n  </div>\n  <div v-else>\n    Now you don't\n  </div>\n  ```\n\n- **See also:**\n  - [Conditional Rendering - v-else](../guide/conditional.html#v-else)\n\n### v-for\n\n- **Expects:** `Array | Object | number | string`\n\n- **Usage:**\n\n  Render the element or template block multiple times based on the source data. The directive's value must use the special syntax `alias in expression` to provide an alias for the current element being iterated on:\n\n  ``` html\n  <div v-for=\"item in items\">\n    {{ item.text }}\n  </div>\n  ```\n\n  Alternatively, you can also specify an alias for the index (or the key if used on an Object):\n\n  ``` html\n  <div v-for=\"(item, index) in items\"></div>\n  <div v-for=\"(val, key) in object\"></div>\n  <div v-for=\"(val, key, index) in object\"></div>\n  ```\n\n  The default behavior of `v-for` will try to patch the elements in-place without moving them. To force it to reorder elements, you need to provide an ordering hint with the `key` special attribute:\n\n  ``` html\n  <div v-for=\"item in items\" :key=\"item.id\">\n    {{ item.text }}\n  </div>\n  ```\n\n  The detailed usage for `v-for` is explained in the guide section linked below.\n\n- **See also:**\n  - [List Rendering](../guide/list.html)\n  - [key](../guide/list.html#key)\n\n### v-on\n\n- **Shorthand:** `@`\n\n- **Expects:** `Function | Inline Statement`\n\n- **Argument:** `event (required)`\n\n- **Modifiers:**\n  - `.stop` - call `event.stopPropagation()`.\n  - `.prevent` - call `event.preventDefault()`.\n  - `.capture` - add event listener in capture mode.\n  - `.self` - only trigger handler if event was dispatched from this element.\n  - `.{keyCode | keyAlias}` - only trigger handler on certain keys.\n  - `.native` - listen for a native event on the root element of component.\n\n- **Usage:**\n\n  Attaches an event listener to the element. The event type is denoted by the argument. The expression can either be a method name or an inline statement, or simply omitted when there are modifiers present.\n\n  When used on a normal element, it listens to **native DOM events** only. When used on a custom element component, it also listens to **custom events** emitted on that child component.\n\n  When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special `$event` property: `v-on:click=\"handle('ok', $event)\"`.\n\n- **Example:**\n\n  ```html\n  <!-- method handler -->\n  <button v-on:click=\"doThis\"></button>\n\n  <!-- inline statement -->\n  <button v-on:click=\"doThat('hello', $event)\"></button>\n\n  <!-- shorthand -->\n  <button @click=\"doThis\"></button>\n\n  <!-- stop propagation -->\n  <button @click.stop=\"doThis\"></button>\n\n  <!-- prevent default -->\n  <button @click.prevent=\"doThis\"></button>\n\n  <!-- prevent default without expression -->\n  <form @submit.prevent></form>\n\n  <!-- chain modifiers -->\n  <button @click.stop.prevent=\"doThis\"></button>\n\n  <!-- key modifier using keyAlias -->\n  <input @keyup.enter=\"onEnter\">\n\n  <!-- key modifier using keyCode -->\n  <input @keyup.13=\"onEnter\">\n  ```\n\n  Listening to custom events on a child component (the handler is called when \"my-event\" is emitted on the child):\n\n  ```html\n  <my-component @my-event=\"handleThis\"></my-component>\n\n  <!-- inline statement -->\n  <my-component @my-event=\"handleThis(123, $event)\"></my-component>\n\n  <!-- native event on component -->\n  <my-component @click.native=\"onClick\"></my-component>\n  ```\n\n- **See also:**\n  - [Methods and Event Handling](../guide/events.html)\n  - [Components - Custom Events](../guide/components.html#Custom-Events)\n\n### v-bind\n\n- **Shorthand:** `:`\n\n- **Expects:** `any (with argument) | Object (without argument)`\n\n- **Argument:** `attrOrProp (optional)`\n\n- **Modifiers:**\n  - `.prop` - Used for binding DOM attributes.\n\n- **Usage:**\n\n  Dynamically bind one or more attributes, or a component prop to an expression.\n\n  When used to bind the `class` or `style` attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.\n\n  When used for prop binding, the prop must be properly declared in the child component.\n\n  When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode `class` and `style` does not support Array or Objects.\n\n- **Example:**\n\n  ```html\n  <!-- bind an attribute -->\n  <img v-bind:src=\"imageSrc\">\n\n  <!-- shorthand -->\n  <img :src=\"imageSrc\">\n\n  <!-- class binding -->\n  <div :class=\"{ red: isRed }\"></div>\n  <div :class=\"[classA, classB]\"></div>\n  <div :class=\"[classA, { classB: isB, classC: isC }]\">\n\n  <!-- style binding -->\n  <div :style=\"{ fontSize: size + 'px' }\"></div>\n  <div :style=\"[styleObjectA, styleObjectB]\"></div>\n\n  <!-- binding an object of attributes -->\n  <div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>\n\n  <!-- DOM attribute binding with prop modifier -->\n  <div v-bind:text-content.prop=\"text\"></div>\n\n  <!-- prop binding. \"prop\" must be declared in my-component. -->\n  <my-component :prop=\"someThing\"></my-component>\n\n  <!-- XLink -->\n  <svg><a :xlink:special=\"foo\"></a></svg>\n  ```\n\n- **See also:**\n  - [Class and Style Bindings](../guide/class-and-style.html)\n  - [Components - Component Props](../guide/components.html#Props)\n\n### v-model\n\n- **Expects:** varies based on value of form inputs element or output of components\n\n- **Limited to:**\n  - `<input>`\n  - `<select>`\n  - `<textarea>`\n  - components\n\n- **Modifiers:**\n  - [`.lazy`](../guide/forms.html#lazy) - listen to `change` events instead of `input`\n  - [`.number`](../guide/forms.html#number) - cast input string to numbers\n  - [`.trim`](/guild/forms.html#trim) - trim input\n\n- **Usage:**\n\n  Create a two-way binding on a form input element or a component. For detailed usage, see guide section linked below.\n\n- **See also:**\n  - [Form Input Bindings](../guide/forms.html)\n  - [Components - Form Input Components using Custom Events](../guide/components.html#Form-Input-Components-using-Custom-Events)\n\n### v-pre\n\n- **Does not expect expression**\n\n- **Usage:**\n\n  Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.\n\n- **Example:**\n\n  ```html\n  <span v-pre>{{ this will not be compiled }}</span>\n   ```\n\n### v-cloak\n\n- **Does not expect expression**\n\n- **Usage:**\n\n  This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as `[v-cloak] { display: none }`, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.\n\n- **Example:**\n\n  ```css\n  [v-cloak] {\n    display: none;\n  }\n  ```\n\n  ```html\n  <div v-cloak>\n    {{ message }}\n  </div>\n  ```\n\n  The `<div>` will not be visible until the compilation is done.\n\n### v-once\n\n- **Does not expect expression**\n\n- **Details:**\n\n  Render the element and component **once** only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.\n\n  ```html\n  <!-- single element -->\n  <span v-once>This will never change: {{msg}}</span>\n  <!-- the element have children -->\n  <div v-once>\n    <h1>comment</h1>\n    <p>{{msg}}</p>\n  </div>\n  <!-- component -->\n  <my-component v-once :comment=\"msg\"></my-component>\n  <!-- v-for directive -->\n  <ul>\n    <li v-for=\"i in list\" v-once>{{i}}</li>\n  </ul>\n  ```\n\n- **See also:**\n  - [Data Binding Syntax - interpolations](../guide/syntax.html#Text)\n  - [Components - Cheap Static Components with v-once](../guide/components.html#Cheap-Static-Components-with-v-once)\n\n## Special Attributes\n\n### key\n\n- **Expects:** `string`\n\n  The `key` special attribute is primarily used as a hint for Vue's virtual DOM algorithm to identify VNodes when diffing the new list of nodes against the old list. Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed/destroyed.\n\n  Children of the same common parent must have **unique keys**. Duplicate keys will cause render errors.\n\n  The most common use case is combined with `v-for`:\n\n  ``` html\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">...</li>\n  </ul>\n  ```\n\n  It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:\n\n  - Properly trigger lifecycle hooks of a component\n  - Trigger transitions\n\n  For example:\n\n  ``` html\n  <transition>\n    <span :key=\"text\">{{ text }}</span>\n  </transition>\n  ```\n\n  When `text` changes, the `<span>` will always be replaced instead of patched, so a transition will be triggered.\n\n### ref\n\n- **Expects:** `string`\n\n  `ref` is used to register a reference to an element or a child component. The reference will be registered under the parent component's `$refs` object. If used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be component instance:\n\n  ``` html\n  <!-- vm.$refs.p will the DOM node -->\n  <p ref=\"p\">hello</p>\n\n  <!-- vm.$refs.child will be the child comp instance -->\n  <child-comp ref=\"child\"></child-comp>\n  ```\n\n  When used on elements/components with `v-for`, the registered reference will be an Array containing DOM nodes or component instances.\n\n  An important note about the ref registration timing: because the refs themselves are created as a result of the render function, you cannot access them on the initial render - they don't exist yet! `$refs` is also non-reactive, therefore you should not attempt to use it in templates for data-binding.\n\n- **See also:** [Child Component Refs](../guide/components.html#Child-Component-Refs)\n\n### slot\n\n- **Expects:** `string`\n\n  Used on content inserted into child components to indicate which named slot the content belongs to.\n\n  For detailed usage, see the guide section linked below.\n\n- **See also:** [Named Slots](../guide/components.html#Named-Slots)\n\n## Built-In Components\n\n### component\n\n- **Props:**\n  - `is` - string | ComponentDefinition | ComponentConstructor\n  - `inline-template` - boolean\n\n- **Usage:**\n\n  A \"meta component\" for rendering dynamic components. The actual component to render is determined by the `is` prop:\n\n  ```html\n  <!-- a dynamic component controlled by -->\n  <!-- the `componentId` property on the vm -->\n  <component :is=\"componentId\"></component>\n\n  <!-- can also render registered component or component passed as prop -->\n  <component :is=\"$options.components.child\"></component>\n  ```\n\n- **See also:** [Dynamic Components](../guide/components.html#Dynamic-Components)\n\n### transition\n\n- **Props:**\n  - `name` - string, Used to automatically generate transition CSS class names. e.g. `name: 'fade'` will auto expand to `.fade-enter`, `.fade-enter-active`, etc. Defaults to `\"v\"`.\n  - `appear` - boolean, Whether to apply transition on initial render. Defaults to `false`.\n  - `css` - boolean, Whether to apply CSS transition classes. Defaults to `true`. If set to `false`, will only trigger JavaScript hooks registered via component events.\n  - `type` - string, Specify the type of transition events to wait for to determine transition end timing. Available values are `\"transition\"` and `\"animation\"`. By default, it will automatically detect the type that has a longer duration.\n  - `mode` - string, Controls the timing sequence of leaving/entering transitions. Available modes are `\"out-in\"` and `\"in-out\"`; defaults to simultaneous.\n  - `enter-class` - string\n  - `leave-class` - string\n  - `enter-active-class` - string\n  - `leave-active-class` - string\n  - `appear-class` - string\n  - `appear-active-class` - string\n\n- **Events:**\n  - `before-enter`\n  - `enter`\n  - `after-enter`\n  - `before-leave`\n  - `leave`\n  - `after-leave`\n  - `before-appear`\n  - `appear`\n  - `after-appear`\n\n- **Usage:**\n\n  `<transition>` serve as transition effects for **single** element/component. The `<transition>` does not render an extra DOM element, nor does it show up in the inspected component hierarchy. It simply applies the transition behavior to the wrapped content inside.\n\n  ```html\n  <!-- simple element -->\n  <transition>\n    <div v-if=\"ok\">toggled content</div>\n  </transition>\n\n  <!-- dynamic component -->\n  <transition name=\"fade\" mode=\"out-in\" appear>\n    <component :is=\"view\"></component>\n  </transition>\n\n  <!-- event hooking -->\n  <div id=\"transition-demo\">\n    <transition @after-enter=\"transitionComplete\">\n      <div v-show=\"ok\">toggled content</div>\n    </transition>\n  </div>\n  ```\n\n  ``` js\n  new Vue({\n    ...\n    methods: {\n      transitionComplete: function (el) {\n        // for passed 'el' that DOM element as the argument, something ...\n      }\n    }\n    ...\n  }).$mount('#transition-demo')\n  ```\n\n- **See also:** [Transitions: Entering, Leaving, and Lists](../guide/transitions.html)\n\n### transition-group\n\n- **Props:**\n  - `tag` - string, defaults to `span`.\n  - `move-class` - overwrite CSS class applied during moving transition.\n  - exposes the same props as `<transition>` except `mode`.\n\n- **Events:**\n  - exposes the same events as `<transition>`.\n\n- **Usage:**\n\n  `<transition-group>` serve as transition effects for **multiple** elements/components. The `<transition-group>` renders a real DOM element. By default it renders a `<span>`, and you can configure what element is should render via the `tag` attribute.\n\n  Note every child in a `<transition-group>` must be **uniquely keyed** for the animations to work properly.\n\n  `<transition-group>` supports moving transitions via CSS transform. When a child's position on screen has changed after an updated, it will get applied a moving CSS class (auto generated from the `name` attribute or configured with the `move-class` attribute). If the CSS `transform` property is \"transition-able\" when the moving class is applied, the element will be smoothly animated to its destination using the [FLIP technique](https://aerotwist.com/blog/flip-your-animations/).\n\n  ```html\n  <transition-group tag=\"ul\" name=\"slide\">\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </transition-group>\n  ```\n\n- **See also:** [Transitions: Entering, Leaving, and Lists](../guide/transitions.html)\n\n### keep-alive\n\n- **Usage:**\n\n  When wrapped around a dynamic component, `<keep-alive>` caches the inactive component instances without destroying them. Similar to `<transition>`, `<keep-alive>` is an abstract component: it doesn't render a DOM element itself, and doesn't show up in the component parent chain.\n\n  When a component is toggled inside `<keep-alive>`, its `activated` and `deactivated` lifecycle hooks will be invoked accordingly.\n\n  Primarily used with preserve component state or avoid re-rendering.\n\n  ```html\n  <!-- basic -->\n  <keep-alive>\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- multiple conditional children -->\n  <keep-alive>\n    <comp-a v-if=\"a > 1\"></comp-a>\n    <comp-b v-else></comp-b>\n  </keep-alive>\n\n  <!-- used together with <transition> -->\n  <transition>\n    <keep-alive>\n      <component :is=\"view\"></component>\n    </keep-alive>\n  </transition>\n  ```\n\n  <p class=\"tip\">`<keep-alive>` does not work with functional components because they do not have instances to be cached.</p>\n\n- **See also:** [Dynamic Components - keep-alive](../guide/components.html#keep-alive)\n\n### slot\n\n- **Props:**\n  - `name` - string, Used for named slot.\n\n- **Usage:**\n\n  `<slot>` serve as content distribution outlets in component templates. `<slot>` itself will be replaced.\n\n  For detailed usage, see the guide section linked below.\n\n- **See also:** [Content Distribution with Slots](../guide/components.html#Content-Distribution-with-Slots)\n\n## VNode Interface\n\n- Please refer to the [VNode class declaration](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js).\n\n## Server-Side Rendering\n\n- Please refer to the [vue-server-renderer package documentation](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer).\n -->\n","source":"docs/index.md","raw":"---\ntype: docs\n---\n\n## Introduction\n\n**Zman** is a PHP package that makes Jewish date conversions simple and easy.\n\nThe `Zman` class is inherited from the amazing [briannesbitt/Carbon](https://github.com/briannesbitt/Carbon) which in turn inherits from PHP's [DateTime](http://www.php.net/manual/en/class.datetime.php) class, thus giving us access to some pretty nifty methods.\n\n## Instantiation\n\nThere are three different ways to create a new instance of `Zman`.\n\n```PHP\n$zman = new Zman('first day of November 2016');\n$zman = Zman::parse('first day of November 2016');\n$zman = Zman::now();\n```\n<!-- \n\n### silent\n\n- **Type:** `boolean`\n\n- **Default:** `false`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.silent = true\n  ```\n\n  Suppress all Vue logs and warnings.\n\n### optionMergeStrategies\n\n- **Type:** `{ [key: string]: Function }`\n\n- **Default:** `{}`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {\n    return child + 1\n  }\n\n  const Profile = Vue.extend({\n    _my_option: 1\n  })\n\n  // Profile.options._my_option = 2\n  ```\n\n  Define custom merging strategies for options.\n\n  The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument.\n\n- **See also:** [Custom Option Merging Strategies](../guide/mixins.html#Custom-Option-Merge-Strategies)\n\n### devtools\n\n- **Type:** `boolean`\n\n- **Default:** `true` (`false` in production builds)\n\n- **Usage:**\n\n  ``` js\n  // make sure to set this synchronously immediately after loading Vue\n  Vue.config.devtools = true\n  ```\n\n  Configure whether to allow [vue-devtools](https://github.com/vuejs/vue-devtools) inspection. This option's default value is `true` in development builds and `false` in production builds. You can set it to `true` to enable inspection for production builds.\n\n### errorHandler\n\n- **Type:** `Function`\n\n- **Default:** Error is thrown in place\n\n- **Usage:**\n\n  ``` js\n  Vue.config.errorHandler = function (err, vm) {\n    // handle error\n  }\n  ```\n\n  Assign a handler for uncaught errors during component render and watchers. The handler gets called with the error and the Vue instance.\n\n  > [Sentry](https://sentry.io), an error tracking service, provides [official integration](https://sentry.io/for/vue/) using this option.\n\n### ignoredElements\n\n- **Type:** `Array<string>`\n\n- **Default:** `[]`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.ignoredElements = [\n    'my-custom-web-component', 'another-web-component'\n  ]\n  ```\n\n  Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an `Unknown custom element`, assuming that you forgot to register a global component or misspelled a component name.\n\n### keyCodes\n\n- **Type:** `{ [key: string]: number }`\n\n- **Default:** `{}`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.keyCodes = {\n    v: 86,\n    f1: 112,\n    mediaPlayPause: 179\n  }\n  ```\n\n  Define custom key alias(es) for v-on.\n\n## Global API\n\n<h3 id=\"Vue-extend\">Vue.extend( options )</h3>\n\n- **Arguments:**\n  - `{Object} options`\n\n- **Usage:**\n\n  Create a \"subclass\" of the base Vue constructor. The argument should be an object containing component options.\n\n  The special case to note here is the `data` option - it must be a function when used with `Vue.extend()`.\n\n  ``` html\n  <div id=\"mount-point\"></div>\n  ```\n\n  ``` js\n  // create constructor\n  var Profile = Vue.extend({\n    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',\n    data: function () {\n      return {\n        firstName: 'Walter',\n        lastName: 'White',\n        alias: 'Heisenberg'\n      }\n    }\n  })\n  // create an instance of Profile and mount it on an element\n  new Profile().$mount('#mount-point')\n  ```\n\n  Will result in:\n\n  ``` html\n  <p>Walter White aka Heisenberg</p>\n  ```\n\n- **See also:** [Components](../guide/components.html)\n\n<h3 id=\"Vue-nextTick\">Vue.nextTick( callback, [context] )</h3>\n\n- **Arguments:**\n  - `{Function} callback`\n  - `{Object} [context]`\n\n- **Usage:**\n\n  Defer the callback to be executed after the next DOM update cycle. Use it immediately after you've changed some data to wait for the DOM update.\n\n  ``` js\n  // modify data\n  vm.msg = 'Hello'\n  // DOM not updated yet\n  Vue.nextTick(function () {\n    // DOM updated\n  })\n  ```\n\n- **See also:** [Async Update Queue](../guide/reactivity.html#Async-Update-Queue)\n\n<h3 id=\"Vue-set\">Vue.set( object, key, value )</h3>\n\n- **Arguments:**\n  - `{Object} object`\n  - `{string} key`\n  - `{any} value`\n\n- **Returns:** the set value.\n\n- **Usage:**\n\n  Set a property on an object. If the object is reactive, ensure the property is created as a reactive property and trigger view updates. This is primarily used to get around the limitation that Vue cannot detect property additions.\n\n  **Note the object cannot be a Vue instance, or the root data object of a Vue instance.**\n\n- **See also:** [Reactivity in Depth](../guide/reactivity.html)\n\n<h3 id=\"Vue-delete\">Vue.delete( object, key )</h3>\n\n- **Arguments:**\n  - `{Object} object`\n  - `{string} key`\n\n- **Usage:**\n\n  Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates. This is primarily used to get around the limitation that Vue cannot detect property deletions, but you should rarely need to use it.\n\n  **Note the object cannot be a Vue instance, or the root data object of a Vue instance.**\n\n- **See also:** [Reactivity in Depth](../guide/reactivity.html)\n\n<h3 id=\"Vue-directive\">Vue.directive( id, [definition] )</h3>\n\n- **Arguments:**\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **Usage:**\n\n  Register or retrieve a global directive.\n\n  ``` js\n  // register\n  Vue.directive('my-directive', {\n    bind: function () {},\n    inserted: function () {},\n    update: function () {},\n    componentUpdated: function () {},\n    unbind: function () {}\n  })\n\n  // register (simple function directive)\n  Vue.directive('my-directive', function () {\n    // this will be called as `bind` and `update`\n  })\n\n  // getter, return the directive definition if registered\n  var myDirective = Vue.directive('my-directive')\n  ```\n\n- **See also:** [Custom Directives](../guide/custom-directive.html)\n\n<h3 id=\"Vue-filter\">Vue.filter( id, [definition] )</h3>\n\n- **Arguments:**\n  - `{string} id`\n  - `{Function} [definition]`\n\n- **Usage:**\n\n  Register or retrieve a global filter.\n\n  ``` js\n  // register\n  Vue.filter('my-filter', function (value) {\n    // return processed value\n  })\n\n  // getter, return the filter if registered\n  var myFilter = Vue.filter('my-filter')\n  ```\n\n<h3 id=\"Vue-component\">Vue.component( id, [definition] )</h3>\n\n- **Arguments:**\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **Usage:**\n\n  Register or retrieve a global component. Registration also automatically sets the component's `name` with the given `id`.\n\n  ``` js\n  // register an extended constructor\n  Vue.component('my-component', Vue.extend({ /* ... */ }))\n\n  // register an options object (automatically call Vue.extend)\n  Vue.component('my-component', { /* ... */ })\n\n  // retrieve a registered component (always return constructor)\n  var MyComponent = Vue.component('my-component')\n  ```\n\n- **See also:** [Components](../guide/components.html)\n\n<h3 id=\"Vue-use\">Vue.use( plugin )</h3>\n\n- **Arguments:**\n  - `{Object | Function} plugin`\n\n- **Usage:**\n\n  Install a Vue.js plugin. If the plugin is an Object, it must expose an `install` method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.\n\n  When this method is called on the same plugin multiple times, the plugin will be installed only once.\n\n- **See also:** [Plugins](../guide/plugins.html)\n\n<h3 id=\"Vue-mixin\">Vue.mixin( mixin )</h3>\n\n- **Arguments:**\n  - `{Object} mixin`\n\n- **Usage:**\n\n  Apply a mixin globally, which affects every Vue instance created afterwards. This can be used by plugin authors to inject custom behavior into components. **Not recommended in application code**.\n\n- **See also:** [Global Mixins](../guide/mixins.html#Global-Mixin)\n\n<h3 id=\"Vue-compile\">Vue.compile( template )</h3>\n\n- **Arguments:**\n  - `{string} template`\n\n- **Usage:**\n\n  Compiles a template string into a render function. **Only available in the standalone build.**\n\n  ``` js\n  var res = Vue.compile('<div><span>{{ msg }}</span></div>')\n\n  new Vue({\n    data: {\n      msg: 'hello'\n    },\n    render: res.render,\n    staticRenderFns: res.staticRenderFns\n  })\n  ```\n\n- **See also:** [Render Functions](../guide/render-function.html)\n\n## Options / Data\n\n### data\n\n- **Type:** `Object | Function`\n\n- **Restriction:** Only accepts `Function` when used in a component definition.\n\n- **Details:**\n\n  The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it \"reactive\". **The object must be plain**: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with its own stateful behavior.\n\n  Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.\n\n  After the instance is created, the original data object can be accessed as `vm.$data`. The Vue instance also proxies all the properties found on the data object, so `vm.a` will be equivalent to `vm.$data.a`.\n\n  Properties that start with `_` or `$` will **not** be proxied on the Vue instance because they may conflict with Vue's internal properties and API methods. You will have to access them as `vm.$data._property`.\n\n  When defining a **component**, `data` must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we still use a plain object for `data`, that same object will be **shared by reference** across all instances created! By providing a `data` function, every time a new instance is created, we can simply call it to return a fresh copy of the initial data.\n\n  If required, a deep clone of the original object can be obtained by passing `vm.$data` through `JSON.parse(JSON.stringify(...))`.\n\n- **Example:**\n\n  ``` js\n  var data = { a: 1 }\n\n  // direct instance creation\n  var vm = new Vue({\n    data: data\n  })\n  vm.a // -> 1\n  vm.$data === data // -> true\n\n  // must use function when in Vue.extend()\n  var Component = Vue.extend({\n    data: function () {\n      return { a: 1 }\n    }\n  })\n  ```\n\n  <p class=\"tip\">Note that __you should not use an arrow function with the `data` property__ (e.g. `data: () => { return { a: this.myProp }}`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.myProp` will be undefined.</p>\n\n- **See also:** [Reactivity in Depth](../guide/reactivity.html)\n\n### props\n\n- **Type:** `Array<string> | Object`\n\n- **Details:**\n\n  A list/hash of attributes that are exposed to accept data from the parent component. It has a simple Array-based syntax and an alternative Object-based syntax that allows advanced configurations such as type checking, custom validation and default values.\n\n- **Example:**\n\n  ``` js\n  // simple syntax\n  Vue.component('props-demo-simple', {\n    props: ['size', 'myMessage']\n  })\n\n  // object syntax with validation\n  Vue.component('props-demo-advanced', {\n    props: {\n      // just type check\n      height: Number,\n      // type check plus other validations\n      age: {\n        type: Number,\n        default: 0,\n        required: true,\n        validator: function (value) {\n          return value >= 0\n        }\n      }\n    }\n  })\n  ```\n\n- **See also:** [Props](../guide/components.html#Props)\n\n### propsData\n\n- **Type:** `{ [key: string]: any }`\n\n- **Restriction:** only respected in instance creation via `new`.\n\n- **Details:**\n\n  Pass props to an instance during its creation. This is primarily intended to make unit testing easier.\n\n- **Example:**\n\n  ``` js\n  var Comp = Vue.extend({\n    props: ['msg'],\n    template: '<div>{{ msg }}</div>'\n  })\n\n  var vm = new Comp({\n    propsData: {\n      msg: 'hello'\n    }\n  })\n  ```\n\n### computed\n\n- **Type:** `{ [key: string]: Function | { get: Function, set: Function } }`\n\n- **Details:**\n\n  Computed properties to be mixed into the Vue instance. All getters and setters have their `this` context automatically bound to the Vue instance.\n\n  <p class=\"tip\">Note that __you should not use an arrow function to define a computed property__ (e.g. `aDouble: () => this.a * 2`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.a` will be undefined.</p>\n\n  Computed properties are cached, and only re-computed on reactive dependency changes.\n\n- **Example:**\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    computed: {\n      // get only, just need a function\n      aDouble: function () {\n        return this.a * 2\n      },\n      // both get and set\n      aPlus: {\n        get: function () {\n          return this.a + 1\n        },\n        set: function (v) {\n          this.a = v - 1\n        }\n      }\n    }\n  })\n  vm.aPlus   // -> 2\n  vm.aPlus = 3\n  vm.a       // -> 2\n  vm.aDouble // -> 4\n  ```\n\n- **See also:**\n  - [Computed Properties](../guide/computed.html)\n\n### methods\n\n- **Type:** `{ [key: string]: Function }`\n\n- **Details:**\n\n  Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their `this` context automatically bound to the Vue instance.\n\n  <p class=\"tip\">Note that __you should not use an arrow function to define a method__ (e.g. `plus: () => this.a++`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.a` will be undefined.</p>\n\n- **Example:**\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    methods: {\n      plus: function () {\n        this.a++\n      }\n    }\n  })\n  vm.plus()\n  vm.a // 2\n  ```\n\n- **See also:** [Methods and Event Handling](../guide/events.html)\n\n### watch\n\n- **Type:** `{ [key: string]: string | Function | Object }`\n\n- **Details:**\n\n  An object where keys are expressions to watch and values are the corresponding callbacks. The value can also be a string of a method name, or an Object that contains additional options. The Vue instance will call `$watch()` for each entry in the object at instantiation.\n\n- **Example:**\n\n  ``` js\n  var vm = new Vue({\n    data: {\n      a: 1,\n      b: 2,\n      c: 3\n    },\n    watch: {\n      a: function (val, oldVal) {\n        console.log('new: %s, old: %s', val, oldVal)\n      },\n      // string method name\n      b: 'someMethod',\n      // deep watcher\n      c: {\n        handler: function (val, oldVal) { /* ... */ },\n        deep: true\n      }\n    }\n  })\n  vm.a = 2 // -> new: 2, old: 1\n  ```\n\n  <p class=\"tip\">Note that __you should not use an arrow function to define a watcher__ (e.g. `searchQuery: newValue => this.updateAutocomplete(newValue)`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.updateAutocomplete` will be undefined.</p>\n\n- **See also:** [Instance Methods - vm.$watch](#vm-watch)\n\n## Options / DOM\n\n### el\n\n- **Type:** `string | HTMLElement`\n\n- **Restriction:** only respected in instance creation via `new`.\n\n- **Details:**\n\n  Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.\n\n  After the instance is mounted, the resolved element will be accessible as `vm.$el`.\n\n  If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call `vm.$mount()` to manually start the compilation.\n\n  <p class=\"tip\">The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to `<html>` or `<body>`.</p>\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### template\n\n- **Type:** `string`\n\n- **Details:**\n\n  A string template to be used as the markup for the Vue instance. The template will **replace** the mounted element. Any existing markup inside the mounted element will be ignored, unless content distribution slots are present in the template.\n\n  If the string starts with `#` it will be used as a querySelector and use the selected element's innerHTML as the template string. This allows the use of the common `<script type=\"x-template\">` trick to include templates.\n\n  <p class=\"tip\">From a security perspective, you should only use Vue templates that you can trust. Never use user-generated content as your template.</p>\n\n- **See also:**\n  - [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n  - [Content Distribution](../guide/components.html#Content-Distribution-with-Slots)\n\n### render\n\n  - **Type:** `Function`\n\n  - **Details:**\n\n    An alternative to string templates allowing you to leverage the full programmatic power of JavaScript. The render function receives a `createElement` method as it's first argument used to create `VNode`s.\n\n    If the component is a functional component, the render function also receives an extra argument `context`, which provides access to contextual data since functional components are instance-less.\n\n  - **See also:**\n    - [Render Functions](../guide/render-function)\n\n## Options / Lifecycle Hooks\n\nAll lifecycle hooks automatically have their `this` context bound to the instance, so that you can access data, computed properties, and methods. This means __you should not use an arrow function to define a lifecycle method__ (e.g. `created: () => this.fetchTodos()`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.fetchTodos` will be undefined.\n\n### beforeCreate\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called synchronously after the instance has just been initialized, before data observation and event/watcher setup.\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### created\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called synchronously after the instance is created. At this stage, the instance has finished processing the options which means the following have been set up: data observation, computed properties, methods, watch/event callbacks. However, the mounting phase has not been started, and the `$el` property will not be available yet.\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### beforeMount\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called right before the mounting begins: the `render` function is about to be called for the first time.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### mounted\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called after the instance has just been mounted where `el` is replaced by the newly created `vm.$el`. If the root instance is mounted to an in-document element, `vm.$el` will also be in-document when `mounted` is called.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### beforeUpdate\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called when the data changes, before the virtual DOM is re-rendered and patched.\n\n  You can perform further state changes in this hook and they will not trigger additional re-renders.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### updated\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called after a data change causes the virtual DOM to be re-rendered and patched.\n\n  The component's DOM will be in updated state when this hook is called, so you can perform DOM-dependent operations in this hook. However, in most cases you should avoid changing state in this hook, because it may lead to an infinite update loop.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### activated\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called when a kept-alive component is activated.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:**\n  - [Built-in Components - keep-alive](#keep-alive)\n  - [Dynamic Components - keep-alive](../guide/components.html#keep-alive)\n\n### deactivated\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called when a kept-alive component is deactivated.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:**\n  - [Built-in Components - keep-alive](#keep-alive)\n  - [Dynamic Components - keep-alive](../guide/components.html#keep-alive)\n\n### beforeDestroy\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called right before a Vue instance is destroyed. At this stage the instance is still fully functional.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### destroyed\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called after a Vue instance has been destroyed. When this hook is called, all directives of the Vue instance have been unbound, all event listeners have been removed, and all child Vue instances have also been destroyed.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n## Options / Assets\n\n### directives\n\n- **Type:** `Object`\n\n- **Details:**\n\n  A hash of directives to be made available to the Vue instance.\n\n- **See also:**\n  - [Custom Directives](../guide/custom-directive.html)\n  - [Assets Naming Convention](../guide/components.html#Assets-Naming-Convention)\n\n### filters\n\n- **Type:** `Object`\n\n- **Details:**\n\n  A hash of filters to be made available to the Vue instance.\n\n- **See also:**\n  - [`Vue.filter`](#Vue-filter)\n\n### components\n\n- **Type:** `Object`\n\n- **Details:**\n\n  A hash of components to be made available to the Vue instance.\n\n- **See also:**\n  - [Components](../guide/components.html)\n\n## Options / Misc\n\n### parent\n\n- **Type:** `Vue instance`\n\n- **Details:**\n\n  Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as `this.$parent` for the child, and the child will be pushed into the parent's `$children` array.\n\n  <p class=\"tip\">Use `$parent` and `$children` sparringly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</p>\n\n### mixins\n\n- **Type:** `Array<Object>`\n\n- **Details:**\n\n  The `mixins` option accepts an array of mixin objects. These mixin objects can contain instance options just like normal instance objects, and they will be merged against the eventual options using the same option merging logic in `Vue.extend()`. e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called.\n\n  Mixin hooks are called in the order they are provided, and called before the component's own hooks.\n\n- **Example:**\n\n  ``` js\n  var mixin = {\n    created: function () { console.log(1) }\n  }\n  var vm = new Vue({\n    created: function () { console.log(2) },\n    mixins: [mixin]\n  })\n  // -> 1\n  // -> 2\n  ```\n\n- **See also:** [Mixins](../guide/mixins.html)\n\n### name\n\n- **Type:** `string`\n\n- **Restriction:** only respected when used as a component option.\n\n- **Details:**\n\n  Allow the component to recursively invoke itself in its template. Note that when a component is registered globally with `Vue.component()`, the global ID is automatically set as its name.\n\n  Another benefit of specifying a `name` option is debugging. Named components result in more helpful warning messages. Also, when inspecting an app in the [vue-devtools](https://github.com/vuejs/vue-devtools), unnamed components will show up as `<AnonymousComponent>`, which isn't very informative. By providing the `name` option, you will get a much more informative component tree.\n\n### extends\n\n- **Type:** `Object | Function`\n\n- **Details:**\n\n  Allows declaratively extending another component (could be either a plain options object or a constructor) without having to use `Vue.extend`. This is primarily intended to make it easier to extend between single file components.\n\n  This is similar to `mixins`, the difference being that the component's own options takes higher priority than the source component being extended.\n\n- **Example:**\n\n  ``` js\n  var CompA = { ... }\n\n  // extend CompA without having to call Vue.extend on either\n  var CompB = {\n    extends: CompA,\n    ...\n  }\n  ```\n\n### delimiters\n\n- **Type:** `Array<string>`\n\n- **default:** `{% raw %}[\"{{\", \"}}\"]{% endraw %}`\n\n- **Details:**\n\n  Change the plain text interpolation delimiters. **This option is only available in the standalone build.**\n\n- **Example:**\n\n  ``` js\n  new Vue({\n    delimiters: ['${', '}']\n  })\n\n  // Delimiters changed to ES6 template string style\n  ```\n\n### functional\n\n- **Type:** `boolean`\n\n- **Details:**\n\n  Causes a component to be stateless (no `data`) and instanceless (no `this` context). They are simply a `render` function that returns virtual nodes making them much cheaper to render.\n\n- **See also:** [Functional Components](../guide/render-function.html#Functional-Components)\n\n## Instance Properties\n\n### vm.$data\n\n- **Type:** `Object`\n\n- **Details:**\n\n  The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object.\n\n- **See also:** [Options - data](#data)\n\n### vm.$el\n\n- **Type:** `HTMLElement`\n\n- **Read only**\n\n- **Details:**\n\n  The root DOM element that the Vue instance is managing.\n\n### vm.$options\n\n- **Type:** `Object`\n\n- **Read only**\n\n- **Details:**\n\n  The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options:\n\n  ``` js\n  new Vue({\n    customOption: 'foo',\n    created: function () {\n      console.log(this.$options.customOption) // -> 'foo'\n    }\n  })\n  ```\n\n### vm.$parent\n\n- **Type:** `Vue instance`\n\n- **Read only**\n\n- **Details:**\n\n  The parent instance, if the current instance has one.\n\n### vm.$root\n\n- **Type:** `Vue instance`\n\n- **Read only**\n\n- **Details:**\n\n  The root Vue instance of the current component tree. If the current instance has no parents this value will be itself.\n\n### vm.$children\n\n- **Type:** `Array<Vue instance>`\n\n- **Read only**\n\n- **Details:**\n\n  The direct child components of the current instance. **Note there's no order guarantee for `$children`, and it is not reactive.** If you find yourself trying to use `$children` for data binding, consider using an Array and `v-for` to generate child components, and use the Array as the source of truth.\n\n### vm.$slots\n\n- **Type:** `Object`\n\n- **Read only**\n\n- **Details:**\n\n  Used to access content [distributed by slots](../guide/components.html#Content-Distribution-with-Slots). Each [named slot](../guide/components.html#Named-Slots) has its own corresponding property (e.g. the contents of `slot=\"foo\"` will be found at `vm.$slots.foo`). The `default` property contains any nodes not included in a named slot.\n\n  Accessing `vm.$slots` is most useful when writing a component with a [render function](../guide/render-function.html).\n\n- **Example:**\n\n  ```html\n  <blog-post>\n    <h1 slot=\"header\">\n      About Me\n    </h1>\n\n    <p>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.</p>\n\n    <p slot=\"footer\">\n      Copyright 2016 Evan You\n    </p>\n\n    <p>If I have some content down here, it will also be included in vm.$slots.default.</p>.\n  </blog-post>\n  ```\n\n  ```js\n  Vue.component('blog-post', {\n    render: function (createElement) {\n      var header = this.$slots.header\n      var body   = this.$slots.default\n      var footer = this.$slots.footer\n      return createElement('div', [\n        createElement('header', header)\n        createElement('main', body)\n        createElement('footer', footer)\n      ])\n    }\n  })\n  ```\n\n- **See also:**\n  - [`<slot>` Component](#slot)\n  - [Content Distribution with Slots](../guide/components.html#Content-Distribution-with-Slots)\n  - [Render Functions](../guide/render-function.html)\n\n### vm.$refs\n\n- **Type:** `Object`\n\n- **Read only**\n\n- **Details:**\n\n  An object that holds child components that have `ref` registered.\n\n- **See also:**\n  - [Child Component Refs](../guide/components.html#Child-Component-Refs)\n  - [ref](#ref)\n\n### vm.$isServer\n\n- **Type:** `boolean`\n\n- **Read only**\n\n- **Details:**\n\n  Whether the current Vue instance is running on the server.\n\n- **See also:** [Server-Side Rendering](../guide/ssr.html)\n\n## Instance Methods / Data\n\n<h3 id=\"vm-watch\">vm.$watch( expOrFn, callback, [options] )</h3>\n\n- **Arguments:**\n  - `{string | Function} expOrFn`\n  - `{Function} callback`\n  - `{Object} [options]`\n    - `{boolean} deep`\n    - `{boolean} immediate`\n\n- **Returns:** `{Function} unwatch`\n\n- **Usage:**\n\n  Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts simple dot-delimited paths. For more complex expression, use a function instead.\n\n<p class=\"tip\">Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn't keep a copy of the pre-mutate value.</p>\n\n- **Example:**\n\n  ``` js\n  // keypath\n  vm.$watch('a.b.c', function (newVal, oldVal) {\n    // do something\n  })\n\n  // function\n  vm.$watch(\n    function () {\n      return this.a + this.b\n    },\n    function (newVal, oldVal) {\n      // do something\n    }\n  )\n  ```\n\n  `vm.$watch` returns an unwatch function that stops firing the callback:\n\n  ``` js\n  var unwatch = vm.$watch('a', cb)\n  // later, teardown the watcher\n  unwatch()\n  ```\n\n- **Option: deep**\n\n  To also detect nested value changes inside Objects, you need to pass in `deep: true` in the options argument. Note that you don't need to do so to listen for Array mutations.\n\n  ``` js\n  vm.$watch('someObject', callback, {\n    deep: true\n  })\n  vm.someObject.nestedValue = 123\n  // callback is fired\n  ```\n\n- **Option: immediate**\n\n  Passing in `immediate: true` in the option will trigger the callback immediately with the current value of the expression:\n\n  ``` js\n  vm.$watch('a', callback, {\n    immediate: true\n  })\n  // callback is fired immediately with current value of `a`\n  ```\n\n<h3 id=\"vm-set\">vm.$set( object, key, value )</h3>\n\n- **Arguments:**\n  - `{Object} object`\n  - `{string} key`\n  - `{any} value`\n\n- **Returns:** the set value.\n\n- **Usage:**\n\n  This is the **alias** of the global `Vue.set`.\n\n- **See also:** [Vue.set](#Vue-set)\n\n<h3 id=\"vm-delete\">vm.$delete( object, key )</h3>\n\n- **Arguments:**\n  - `{Object} object`\n  - `{string} key`\n\n- **Usage:**\n\n  This is the **alias** of the global `Vue.delete`.\n\n- **See also:** [Vue.delete](#Vue-delete)\n\n## Instance Methods / Events\n\n<h3 id=\"vm-on\">vm.$on( event, callback )</h3>\n\n- **Arguments:**\n  - `{string} event`\n  - `{Function} callback`\n\n- **Usage:**\n\n  Listen for a custom event on the current vm. Events can be triggered by `vm.$emit`. The callback will receive all the additional arguments passed into these event-triggering methods.\n\n- **Example:**\n\n  ``` js\n  vm.$on('test', function (msg) {\n    console.log(msg)\n  })\n  vm.$emit('test', 'hi')\n  // -> \"hi\"\n  ```\n\n<h3 id=\"vm-once\">vm.$once( event, callback )</h3>\n\n- **Arguments:**\n  - `{string} event`\n  - `{Function} callback`\n\n- **Usage:**\n\n  Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.\n\n<h3 id=\"vm-off\">vm.$off( [event, callback] )</h3>\n\n- **Arguments:**\n  - `{string} [event]`\n  - `{Function} [callback]`\n\n- **Usage:**\n\n  Remove event listener(s).\n\n  - If no arguments are provided, remove all event listeners;\n\n  - If only the event is provided, remove all listeners for that event;\n\n  - If both event and callback are given, remove the listener for that specific callback only.\n\n<h3 id=\"vm-emit\">vm.$emit( event, [...args] )</h3>\n\n- **Arguments:**\n  - `{string} event`\n  - `[...args]`\n\n  Trigger an event on the current instance. Any additional arguments will be passed into the listener's callback function.\n\n## Instance Methods / Lifecycle\n\n<h3 id=\"vm-mount\">vm.$mount( [elementOrSelector] )</h3>\n\n- **Arguments:**\n  - `{Element | string} [elementOrSelector]`\n  - `{boolean} [hydrating]`\n\n- **Returns:** `vm` - the instance itself\n\n- **Usage:**\n\n  If a Vue instance didn't receive the `el` option at instantiation, it will be in \"unmounted\" state, without an associated DOM element. `vm.$mount()` can be used to manually start the mounting of an unmounted Vue instance.\n\n  If `elementOrSelector` argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.\n\n  The method returns the instance itself so you can chain other instance methods after it.\n\n- **Example:**\n\n  ``` js\n  var MyComponent = Vue.extend({\n    template: '<div>Hello!</div>'\n  })\n\n  // create and mount to #app (will replace #app)\n  new MyComponent().$mount('#app')\n\n  // the above is the same as:\n  new MyComponent({ el: '#app' })\n\n  // or, render off-document and append afterwards:\n  var component = new MyComponent().$mount()\n  document.getElementById('app').appendChild(component.$el)\n  ```\n\n- **See also:**\n  - [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n  - [Server-Side Rendering](../guide/ssr.html)\n\n<h3 id=\"vm-forceUpdate\">vm.$forceUpdate()</h3>\n\n- **Usage:**\n\n  Force the Vue instance to re-render. Note it does not affect all child components, only the instance itself and child components with inserted slot content.\n\n<h3 id=\"vm-nextTick\">vm.$nextTick( callback )</h3>\n\n- **Arguments:**\n  - `{Function} callback`\n\n- **Usage:**\n\n  Defer the callback to be executed after the next DOM update cycle. Use it immediately after you've changed some data to wait for the DOM update. This is the same as the global `Vue.nextTick`, except that the callback's `this` context is automatically bound to the instance calling this method.\n\n- **Example:**\n\n  ``` js\n  new Vue({\n    // ...\n    methods: {\n      // ...\n      example: function () {\n        // modify data\n        this.message = 'changed'\n        // DOM is not updated yet\n        this.$nextTick(function () {\n          // DOM is now updated\n          // `this` is bound to the current instance\n          this.doSomethingElse()\n        })\n      }\n    }\n  })\n  ```\n\n- **See also:**\n  - [Vue.nextTick](#Vue-nextTick)\n  - [Async Update Queue](../guide/reactivity.html#Async-Update-Queue)\n\n<h3 id=\"vm-destroy\">vm.$destroy()</h3>\n\n- **Usage:**\n\n  Completely destroy a vm. Clean up its connections with other existing vms, unbind all its directives, turn off all event listeners.\n\n  Triggers the `beforeDestroy` and `destroyed` hooks.\n\n  <p class=\"tip\">In normal use cases you shouldn't have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using `v-if` and `v-for`.</p>\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n## Directives\n\n### v-text\n\n- **Expects:** `string`\n\n- **Details:**\n\n  Updates the element's `textContent`. If you need to update the part of `textContent`, you should use `{% raw %}{{ Mustache }}{% endraw %}` interpolations.\n\n- **Example:**\n\n  ```html\n  <span v-text=\"msg\"></span>\n  <!-- same as -->\n  <span>{{msg}}</span>\n  ```\n\n- **See also:** [Data Binding Syntax - interpolations](../guide/syntax.html#Text)\n\n### v-html\n\n- **Expects:** `string`\n\n- **Details:**\n\n  Updates the element's `innerHTML`. **Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates**. If you find yourself trying to compose templates using `v-html`, try to rethink the solution by using components instead.\n\n  <p class=\"tip\">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to [XSS attacks](https://en.wikipedia.org/wiki/Cross-site_scripting). Only use `v-html` on trusted content and **never** on user-provided content.</p>\n\n- **Example:**\n\n  ```html\n  <div v-html=\"html\"></div>\n  ```\n- **See also:** [Data Binding Syntax - interpolations](../guide/syntax.html#Raw-HTML)\n\n### v-if\n\n- **Expects:** `any`\n\n- **Usage:**\n\n  Conditionally render the element based on the truthy-ness of the expression value. The element and its contained directives / components are destroyed and re-constructed during toggles. If the element is a `<template>` element, its content will be extracted as the conditional block.\n\n  This directive triggers transitions when its condition changes.\n\n- **See also:** [Conditional Rendering - v-if](../guide/conditional.html)\n\n### v-show\n\n- **Expects:** `any`\n\n- **Usage:**\n\n  Toggle's the element's `display` CSS property based on the truthy-ness of the expression value.\n\n  This directive triggers transitions when its condition changes.\n\n- **See also:** [Conditional Rendering - v-show](../guide/conditional.html#v-show)\n\n### v-else\n\n- **Does not expect expression**\n\n- **Restriction:** previous sibling element must have `v-if`.\n\n- **Usage:**\n\n  Denote the \"else block\" for `v-if`.\n\n  ```html\n  <div v-if=\"Math.random() > 0.5\">\n    Now you see me\n  </div>\n  <div v-else>\n    Now you don't\n  </div>\n  ```\n\n- **See also:**\n  - [Conditional Rendering - v-else](../guide/conditional.html#v-else)\n\n### v-for\n\n- **Expects:** `Array | Object | number | string`\n\n- **Usage:**\n\n  Render the element or template block multiple times based on the source data. The directive's value must use the special syntax `alias in expression` to provide an alias for the current element being iterated on:\n\n  ``` html\n  <div v-for=\"item in items\">\n    {{ item.text }}\n  </div>\n  ```\n\n  Alternatively, you can also specify an alias for the index (or the key if used on an Object):\n\n  ``` html\n  <div v-for=\"(item, index) in items\"></div>\n  <div v-for=\"(val, key) in object\"></div>\n  <div v-for=\"(val, key, index) in object\"></div>\n  ```\n\n  The default behavior of `v-for` will try to patch the elements in-place without moving them. To force it to reorder elements, you need to provide an ordering hint with the `key` special attribute:\n\n  ``` html\n  <div v-for=\"item in items\" :key=\"item.id\">\n    {{ item.text }}\n  </div>\n  ```\n\n  The detailed usage for `v-for` is explained in the guide section linked below.\n\n- **See also:**\n  - [List Rendering](../guide/list.html)\n  - [key](../guide/list.html#key)\n\n### v-on\n\n- **Shorthand:** `@`\n\n- **Expects:** `Function | Inline Statement`\n\n- **Argument:** `event (required)`\n\n- **Modifiers:**\n  - `.stop` - call `event.stopPropagation()`.\n  - `.prevent` - call `event.preventDefault()`.\n  - `.capture` - add event listener in capture mode.\n  - `.self` - only trigger handler if event was dispatched from this element.\n  - `.{keyCode | keyAlias}` - only trigger handler on certain keys.\n  - `.native` - listen for a native event on the root element of component.\n\n- **Usage:**\n\n  Attaches an event listener to the element. The event type is denoted by the argument. The expression can either be a method name or an inline statement, or simply omitted when there are modifiers present.\n\n  When used on a normal element, it listens to **native DOM events** only. When used on a custom element component, it also listens to **custom events** emitted on that child component.\n\n  When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special `$event` property: `v-on:click=\"handle('ok', $event)\"`.\n\n- **Example:**\n\n  ```html\n  <!-- method handler -->\n  <button v-on:click=\"doThis\"></button>\n\n  <!-- inline statement -->\n  <button v-on:click=\"doThat('hello', $event)\"></button>\n\n  <!-- shorthand -->\n  <button @click=\"doThis\"></button>\n\n  <!-- stop propagation -->\n  <button @click.stop=\"doThis\"></button>\n\n  <!-- prevent default -->\n  <button @click.prevent=\"doThis\"></button>\n\n  <!-- prevent default without expression -->\n  <form @submit.prevent></form>\n\n  <!-- chain modifiers -->\n  <button @click.stop.prevent=\"doThis\"></button>\n\n  <!-- key modifier using keyAlias -->\n  <input @keyup.enter=\"onEnter\">\n\n  <!-- key modifier using keyCode -->\n  <input @keyup.13=\"onEnter\">\n  ```\n\n  Listening to custom events on a child component (the handler is called when \"my-event\" is emitted on the child):\n\n  ```html\n  <my-component @my-event=\"handleThis\"></my-component>\n\n  <!-- inline statement -->\n  <my-component @my-event=\"handleThis(123, $event)\"></my-component>\n\n  <!-- native event on component -->\n  <my-component @click.native=\"onClick\"></my-component>\n  ```\n\n- **See also:**\n  - [Methods and Event Handling](../guide/events.html)\n  - [Components - Custom Events](../guide/components.html#Custom-Events)\n\n### v-bind\n\n- **Shorthand:** `:`\n\n- **Expects:** `any (with argument) | Object (without argument)`\n\n- **Argument:** `attrOrProp (optional)`\n\n- **Modifiers:**\n  - `.prop` - Used for binding DOM attributes.\n\n- **Usage:**\n\n  Dynamically bind one or more attributes, or a component prop to an expression.\n\n  When used to bind the `class` or `style` attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.\n\n  When used for prop binding, the prop must be properly declared in the child component.\n\n  When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode `class` and `style` does not support Array or Objects.\n\n- **Example:**\n\n  ```html\n  <!-- bind an attribute -->\n  <img v-bind:src=\"imageSrc\">\n\n  <!-- shorthand -->\n  <img :src=\"imageSrc\">\n\n  <!-- class binding -->\n  <div :class=\"{ red: isRed }\"></div>\n  <div :class=\"[classA, classB]\"></div>\n  <div :class=\"[classA, { classB: isB, classC: isC }]\">\n\n  <!-- style binding -->\n  <div :style=\"{ fontSize: size + 'px' }\"></div>\n  <div :style=\"[styleObjectA, styleObjectB]\"></div>\n\n  <!-- binding an object of attributes -->\n  <div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>\n\n  <!-- DOM attribute binding with prop modifier -->\n  <div v-bind:text-content.prop=\"text\"></div>\n\n  <!-- prop binding. \"prop\" must be declared in my-component. -->\n  <my-component :prop=\"someThing\"></my-component>\n\n  <!-- XLink -->\n  <svg><a :xlink:special=\"foo\"></a></svg>\n  ```\n\n- **See also:**\n  - [Class and Style Bindings](../guide/class-and-style.html)\n  - [Components - Component Props](../guide/components.html#Props)\n\n### v-model\n\n- **Expects:** varies based on value of form inputs element or output of components\n\n- **Limited to:**\n  - `<input>`\n  - `<select>`\n  - `<textarea>`\n  - components\n\n- **Modifiers:**\n  - [`.lazy`](../guide/forms.html#lazy) - listen to `change` events instead of `input`\n  - [`.number`](../guide/forms.html#number) - cast input string to numbers\n  - [`.trim`](/guild/forms.html#trim) - trim input\n\n- **Usage:**\n\n  Create a two-way binding on a form input element or a component. For detailed usage, see guide section linked below.\n\n- **See also:**\n  - [Form Input Bindings](../guide/forms.html)\n  - [Components - Form Input Components using Custom Events](../guide/components.html#Form-Input-Components-using-Custom-Events)\n\n### v-pre\n\n- **Does not expect expression**\n\n- **Usage:**\n\n  Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.\n\n- **Example:**\n\n  ```html\n  <span v-pre>{{ this will not be compiled }}</span>\n   ```\n\n### v-cloak\n\n- **Does not expect expression**\n\n- **Usage:**\n\n  This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as `[v-cloak] { display: none }`, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.\n\n- **Example:**\n\n  ```css\n  [v-cloak] {\n    display: none;\n  }\n  ```\n\n  ```html\n  <div v-cloak>\n    {{ message }}\n  </div>\n  ```\n\n  The `<div>` will not be visible until the compilation is done.\n\n### v-once\n\n- **Does not expect expression**\n\n- **Details:**\n\n  Render the element and component **once** only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.\n\n  ```html\n  <!-- single element -->\n  <span v-once>This will never change: {{msg}}</span>\n  <!-- the element have children -->\n  <div v-once>\n    <h1>comment</h1>\n    <p>{{msg}}</p>\n  </div>\n  <!-- component -->\n  <my-component v-once :comment=\"msg\"></my-component>\n  <!-- v-for directive -->\n  <ul>\n    <li v-for=\"i in list\" v-once>{{i}}</li>\n  </ul>\n  ```\n\n- **See also:**\n  - [Data Binding Syntax - interpolations](../guide/syntax.html#Text)\n  - [Components - Cheap Static Components with v-once](../guide/components.html#Cheap-Static-Components-with-v-once)\n\n## Special Attributes\n\n### key\n\n- **Expects:** `string`\n\n  The `key` special attribute is primarily used as a hint for Vue's virtual DOM algorithm to identify VNodes when diffing the new list of nodes against the old list. Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed/destroyed.\n\n  Children of the same common parent must have **unique keys**. Duplicate keys will cause render errors.\n\n  The most common use case is combined with `v-for`:\n\n  ``` html\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">...</li>\n  </ul>\n  ```\n\n  It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:\n\n  - Properly trigger lifecycle hooks of a component\n  - Trigger transitions\n\n  For example:\n\n  ``` html\n  <transition>\n    <span :key=\"text\">{{ text }}</span>\n  </transition>\n  ```\n\n  When `text` changes, the `<span>` will always be replaced instead of patched, so a transition will be triggered.\n\n### ref\n\n- **Expects:** `string`\n\n  `ref` is used to register a reference to an element or a child component. The reference will be registered under the parent component's `$refs` object. If used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be component instance:\n\n  ``` html\n  <!-- vm.$refs.p will the DOM node -->\n  <p ref=\"p\">hello</p>\n\n  <!-- vm.$refs.child will be the child comp instance -->\n  <child-comp ref=\"child\"></child-comp>\n  ```\n\n  When used on elements/components with `v-for`, the registered reference will be an Array containing DOM nodes or component instances.\n\n  An important note about the ref registration timing: because the refs themselves are created as a result of the render function, you cannot access them on the initial render - they don't exist yet! `$refs` is also non-reactive, therefore you should not attempt to use it in templates for data-binding.\n\n- **See also:** [Child Component Refs](../guide/components.html#Child-Component-Refs)\n\n### slot\n\n- **Expects:** `string`\n\n  Used on content inserted into child components to indicate which named slot the content belongs to.\n\n  For detailed usage, see the guide section linked below.\n\n- **See also:** [Named Slots](../guide/components.html#Named-Slots)\n\n## Built-In Components\n\n### component\n\n- **Props:**\n  - `is` - string | ComponentDefinition | ComponentConstructor\n  - `inline-template` - boolean\n\n- **Usage:**\n\n  A \"meta component\" for rendering dynamic components. The actual component to render is determined by the `is` prop:\n\n  ```html\n  <!-- a dynamic component controlled by -->\n  <!-- the `componentId` property on the vm -->\n  <component :is=\"componentId\"></component>\n\n  <!-- can also render registered component or component passed as prop -->\n  <component :is=\"$options.components.child\"></component>\n  ```\n\n- **See also:** [Dynamic Components](../guide/components.html#Dynamic-Components)\n\n### transition\n\n- **Props:**\n  - `name` - string, Used to automatically generate transition CSS class names. e.g. `name: 'fade'` will auto expand to `.fade-enter`, `.fade-enter-active`, etc. Defaults to `\"v\"`.\n  - `appear` - boolean, Whether to apply transition on initial render. Defaults to `false`.\n  - `css` - boolean, Whether to apply CSS transition classes. Defaults to `true`. If set to `false`, will only trigger JavaScript hooks registered via component events.\n  - `type` - string, Specify the type of transition events to wait for to determine transition end timing. Available values are `\"transition\"` and `\"animation\"`. By default, it will automatically detect the type that has a longer duration.\n  - `mode` - string, Controls the timing sequence of leaving/entering transitions. Available modes are `\"out-in\"` and `\"in-out\"`; defaults to simultaneous.\n  - `enter-class` - string\n  - `leave-class` - string\n  - `enter-active-class` - string\n  - `leave-active-class` - string\n  - `appear-class` - string\n  - `appear-active-class` - string\n\n- **Events:**\n  - `before-enter`\n  - `enter`\n  - `after-enter`\n  - `before-leave`\n  - `leave`\n  - `after-leave`\n  - `before-appear`\n  - `appear`\n  - `after-appear`\n\n- **Usage:**\n\n  `<transition>` serve as transition effects for **single** element/component. The `<transition>` does not render an extra DOM element, nor does it show up in the inspected component hierarchy. It simply applies the transition behavior to the wrapped content inside.\n\n  ```html\n  <!-- simple element -->\n  <transition>\n    <div v-if=\"ok\">toggled content</div>\n  </transition>\n\n  <!-- dynamic component -->\n  <transition name=\"fade\" mode=\"out-in\" appear>\n    <component :is=\"view\"></component>\n  </transition>\n\n  <!-- event hooking -->\n  <div id=\"transition-demo\">\n    <transition @after-enter=\"transitionComplete\">\n      <div v-show=\"ok\">toggled content</div>\n    </transition>\n  </div>\n  ```\n\n  ``` js\n  new Vue({\n    ...\n    methods: {\n      transitionComplete: function (el) {\n        // for passed 'el' that DOM element as the argument, something ...\n      }\n    }\n    ...\n  }).$mount('#transition-demo')\n  ```\n\n- **See also:** [Transitions: Entering, Leaving, and Lists](../guide/transitions.html)\n\n### transition-group\n\n- **Props:**\n  - `tag` - string, defaults to `span`.\n  - `move-class` - overwrite CSS class applied during moving transition.\n  - exposes the same props as `<transition>` except `mode`.\n\n- **Events:**\n  - exposes the same events as `<transition>`.\n\n- **Usage:**\n\n  `<transition-group>` serve as transition effects for **multiple** elements/components. The `<transition-group>` renders a real DOM element. By default it renders a `<span>`, and you can configure what element is should render via the `tag` attribute.\n\n  Note every child in a `<transition-group>` must be **uniquely keyed** for the animations to work properly.\n\n  `<transition-group>` supports moving transitions via CSS transform. When a child's position on screen has changed after an updated, it will get applied a moving CSS class (auto generated from the `name` attribute or configured with the `move-class` attribute). If the CSS `transform` property is \"transition-able\" when the moving class is applied, the element will be smoothly animated to its destination using the [FLIP technique](https://aerotwist.com/blog/flip-your-animations/).\n\n  ```html\n  <transition-group tag=\"ul\" name=\"slide\">\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </transition-group>\n  ```\n\n- **See also:** [Transitions: Entering, Leaving, and Lists](../guide/transitions.html)\n\n### keep-alive\n\n- **Usage:**\n\n  When wrapped around a dynamic component, `<keep-alive>` caches the inactive component instances without destroying them. Similar to `<transition>`, `<keep-alive>` is an abstract component: it doesn't render a DOM element itself, and doesn't show up in the component parent chain.\n\n  When a component is toggled inside `<keep-alive>`, its `activated` and `deactivated` lifecycle hooks will be invoked accordingly.\n\n  Primarily used with preserve component state or avoid re-rendering.\n\n  ```html\n  <!-- basic -->\n  <keep-alive>\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- multiple conditional children -->\n  <keep-alive>\n    <comp-a v-if=\"a > 1\"></comp-a>\n    <comp-b v-else></comp-b>\n  </keep-alive>\n\n  <!-- used together with <transition> -->\n  <transition>\n    <keep-alive>\n      <component :is=\"view\"></component>\n    </keep-alive>\n  </transition>\n  ```\n\n  <p class=\"tip\">`<keep-alive>` does not work with functional components because they do not have instances to be cached.</p>\n\n- **See also:** [Dynamic Components - keep-alive](../guide/components.html#keep-alive)\n\n### slot\n\n- **Props:**\n  - `name` - string, Used for named slot.\n\n- **Usage:**\n\n  `<slot>` serve as content distribution outlets in component templates. `<slot>` itself will be replaced.\n\n  For detailed usage, see the guide section linked below.\n\n- **See also:** [Content Distribution with Slots](../guide/components.html#Content-Distribution-with-Slots)\n\n## VNode Interface\n\n- Please refer to the [VNode class declaration](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js).\n\n## Server-Side Rendering\n\n- Please refer to the [vue-server-renderer package documentation](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer).\n -->\n","date":"2016-11-07T22:23:51.000Z","updated":"2016-11-07T22:23:51.000Z","path":"docs/index.html","title":"","comments":1,"layout":"page","_id":"civ8ndozp0002wqm1uvpm0g3p","content":"<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p><strong>Zman</strong> is a PHP package that makes Jewish date conversions simple and easy.</p>\n<p>The <code>Zman</code> class is inherited from the amazing <a href=\"https://github.com/briannesbitt/Carbon\" target=\"_blank\" rel=\"external\">briannesbitt/Carbon</a> which in turn inherits from PHP’s <a href=\"http://www.php.net/manual/en/class.datetime.php\" target=\"_blank\" rel=\"external\">DateTime</a> class, thus giving us access to some pretty nifty methods.</p>\n<h2 id=\"Instantiation\"><a href=\"#Instantiation\" class=\"headerlink\" title=\"Instantiation\"></a>Instantiation</h2><p>There are three different ways to create a new instance of <code>Zman</code>.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><div class=\"line\">$zman = <span class=\"keyword\">new</span> Zman(<span class=\"string\">'first day of November 2016'</span>);</div><div class=\"line\">$zman = Zman::parse(<span class=\"string\">'first day of November 2016'</span>);</div><div class=\"line\">$zman = Zman::now();</div></pre></td></tr></table></figure>\n<!-- \n\n### silent\n\n- **Type:** `boolean`\n\n- **Default:** `false`\n\n- **Usage:**\n\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.silent = <span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<p>  Suppress all Vue logs and warnings.</p>\n<h3 id=\"optionMergeStrategies\"><a href=\"#optionMergeStrategies\" class=\"headerlink\" title=\"optionMergeStrategies\"></a>optionMergeStrategies</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>{}</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.optionMergeStrategies._my_option = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">parent, child, vm</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> child + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> Profile = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">_my_option</span>: <span class=\"number\">1</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Profile.options._my_option = 2</span></div></pre></td></tr></table></figure>\n<p>Define custom merging strategies for options.</p>\n<p>The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/mixins.html#Custom-Option-Merge-Strategies\">Custom Option Merging Strategies</a></p>\n</li>\n</ul>\n<h3 id=\"devtools\"><a href=\"#devtools\" class=\"headerlink\" title=\"devtools\"></a>devtools</h3><ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>true</code> (<code>false</code> in production builds)</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// make sure to set this synchronously immediately after loading Vue</span></div><div class=\"line\">Vue.config.devtools = <span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<p>Configure whether to allow <a href=\"https://github.com/vuejs/vue-devtools\">vue-devtools</a> inspection. This option’s default value is <code>true</code> in development builds and <code>false</code> in production builds. You can set it to <code>true</code> to enable inspection for production builds.</p>\n</li>\n</ul>\n<h3 id=\"errorHandler\"><a href=\"#errorHandler\" class=\"headerlink\" title=\"errorHandler\"></a>errorHandler</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Default:</strong> Error is thrown in place</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.errorHandler = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, vm</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// handle error</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Assign a handler for uncaught errors during component render and watchers. The handler gets called with the error and the Vue instance.</p>\n<blockquote>\n<p><a href=\"https://sentry.io\">Sentry</a>, an error tracking service, provides <a href=\"https://sentry.io/for/vue/\">official integration</a> using this option.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"ignoredElements\"><a href=\"#ignoredElements\" class=\"headerlink\" title=\"ignoredElements\"></a>ignoredElements</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;string&gt;</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>[]</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.ignoredElements = [</div><div class=\"line\">  <span class=\"string\">'my-custom-web-component'</span>, <span class=\"string\">'another-web-component'</span></div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<p>Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an <code>Unknown custom element</code>, assuming that you forgot to register a global component or misspelled a component name.</p>\n</li>\n</ul>\n<h3 id=\"keyCodes\"><a href=\"#keyCodes\" class=\"headerlink\" title=\"keyCodes\"></a>keyCodes</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: number }</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>{}</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.keyCodes = &#123;</div><div class=\"line\">  <span class=\"attr\">v</span>: <span class=\"number\">86</span>,</div><div class=\"line\">  <span class=\"attr\">f1</span>: <span class=\"number\">112</span>,</div><div class=\"line\">  <span class=\"attr\">mediaPlayPause</span>: <span class=\"number\">179</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Define custom key alias(es) for v-on.</p>\n</li>\n</ul>\n<h2 id=\"Global-API\"><a href=\"#Global-API\" class=\"headerlink\" title=\"Global API\"></a>Global API</h2><h3 id=\"Vue-extend\">Vue.extend( options )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} options</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Create a “subclass” of the base Vue constructor. The argument should be an object containing component options.</p>\n<p>The special case to note here is the <code>data</code> option - it must be a function when used with <code>Vue.extend()</code>.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mount-point\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// create constructor</span></div><div class=\"line\"><span class=\"keyword\">var</span> Profile = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">firstName</span>: <span class=\"string\">'Walter'</span>,</div><div class=\"line\">      <span class=\"attr\">lastName</span>: <span class=\"string\">'White'</span>,</div><div class=\"line\">      <span class=\"attr\">alias</span>: <span class=\"string\">'Heisenberg'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// create an instance of Profile and mount it on an element</span></div><div class=\"line\"><span class=\"keyword\">new</span> Profile().$mount(<span class=\"string\">'#mount-point'</span>)</div></pre></td></tr></table></figure>\n<p>Will result in:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Walter White aka Heisenberg<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html\">Components</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-nextTick\">Vue.nextTick( callback, [context] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Function} callback</code></li>\n<li><code>{Object} [context]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// modify data</span></div><div class=\"line\">vm.msg = <span class=\"string\">'Hello'</span></div><div class=\"line\"><span class=\"comment\">// DOM not updated yet</span></div><div class=\"line\">Vue.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// DOM updated</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html#Async-Update-Queue\">Async Update Queue</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-set\">Vue.set( object, key, value )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> the set value.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Set a property on an object. If the object is reactive, ensure the property is created as a reactive property and trigger view updates. This is primarily used to get around the limitation that Vue cannot detect property additions.</p>\n<p><strong>Note the object cannot be a Vue instance, or the root data object of a Vue instance.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html\">Reactivity in Depth</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-delete\">Vue.delete( object, key )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates. This is primarily used to get around the limitation that Vue cannot detect property deletions, but you should rarely need to use it.</p>\n<p><strong>Note the object cannot be a Vue instance, or the root data object of a Vue instance.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html\">Reactivity in Depth</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-directive\">Vue.directive( id, [definition] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Register or retrieve a global directive.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// register</span></div><div class=\"line\">Vue.directive(<span class=\"string\">'my-directive'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">bind</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">inserted</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">update</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">componentUpdated</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">unbind</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// register (simple function directive)</span></div><div class=\"line\">Vue.directive(<span class=\"string\">'my-directive'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// this will be called as `bind` and `update`</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getter, return the directive definition if registered</span></div><div class=\"line\"><span class=\"keyword\">var</span> myDirective = Vue.directive(<span class=\"string\">'my-directive'</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/custom-directive.html\">Custom Directives</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-filter\">Vue.filter( id, [definition] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Register or retrieve a global filter.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// register</span></div><div class=\"line\">Vue.filter(<span class=\"string\">'my-filter'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// return processed value</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getter, return the filter if registered</span></div><div class=\"line\"><span class=\"keyword\">var</span> myFilter = Vue.filter(<span class=\"string\">'my-filter'</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Vue-component\">Vue.component( id, [definition] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Register or retrieve a global component. Registration also automatically sets the component’s <code>name</code> with the given <code>id</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// register an extended constructor</span></div><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, Vue.extend(&#123; <span class=\"comment\">/* ... */</span> &#125;))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// register an options object (automatically call Vue.extend)</span></div><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123; <span class=\"comment\">/* ... */</span> &#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// retrieve a registered component (always return constructor)</span></div><div class=\"line\"><span class=\"keyword\">var</span> MyComponent = Vue.component(<span class=\"string\">'my-component'</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html\">Components</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-use\">Vue.use( plugin )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object | Function} plugin</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Install a Vue.js plugin. If the plugin is an Object, it must expose an <code>install</code> method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.</p>\n<p>When this method is called on the same plugin multiple times, the plugin will be installed only once.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/plugins.html\">Plugins</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-mixin\">Vue.mixin( mixin )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} mixin</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Apply a mixin globally, which affects every Vue instance created afterwards. This can be used by plugin authors to inject custom behavior into components. <strong>Not recommended in application code</strong>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/mixins.html#Global-Mixin\">Global Mixins</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-compile\">Vue.compile( template )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} template</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Compiles a template string into a render function. <strong>Only available in the standalone build.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> res = Vue.compile(<span class=\"string\">'&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">msg</span>: <span class=\"string\">'hello'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">render</span>: res.render,</div><div class=\"line\">  <span class=\"attr\">staticRenderFns</span>: res.staticRenderFns</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/render-function.html\">Render Functions</a></p>\n</li>\n</ul>\n<h2 id=\"Options-Data\"><a href=\"#Options-Data\" class=\"headerlink\" title=\"Options / Data\"></a>Options / Data</h2><h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><ul>\n<li><p><strong>Type:</strong> <code>Object | Function</code></p>\n</li>\n<li><p><strong>Restriction:</strong> Only accepts <code>Function</code> when used in a component definition.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it “reactive”. <strong>The object must be plain</strong>: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with its own stateful behavior.</p>\n<p>Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.</p>\n<p>After the instance is created, the original data object can be accessed as <code>vm.$data</code>. The Vue instance also proxies all the properties found on the data object, so <code>vm.a</code> will be equivalent to <code>vm.$data.a</code>.</p>\n<p>Properties that start with <code>_</code> or <code>$</code> will <strong>not</strong> be proxied on the Vue instance because they may conflict with Vue’s internal properties and API methods. You will have to access them as <code>vm.$data._property</code>.</p>\n<p>When defining a <strong>component</strong>, <code>data</code> must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we still use a plain object for <code>data</code>, that same object will be <strong>shared by reference</strong> across all instances created! By providing a <code>data</code> function, every time a new instance is created, we can simply call it to return a fresh copy of the initial data.</p>\n<p>If required, a deep clone of the original object can be obtained by passing <code>vm.$data</code> through <code>JSON.parse(JSON.stringify(...))</code>.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// direct instance creation</span></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: data</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.a <span class=\"comment\">// -&gt; 1</span></div><div class=\"line\">vm.$data === data <span class=\"comment\">// -&gt; true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// must use function when in Vue.extend()</span></div><div class=\"line\"><span class=\"keyword\">var</span> Component = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p class=\"tip\">Note that <strong>you should not use an arrow function with the <code>data</code> property</strong> (e.g. <code>data: () =&gt; { return { a: this.myProp }}</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.myProp</code> will be undefined.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html\">Reactivity in Depth</a></p>\n</li>\n</ul>\n<h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;string&gt; | Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A list/hash of attributes that are exposed to accept data from the parent component. It has a simple Array-based syntax and an alternative Object-based syntax that allows advanced configurations such as type checking, custom validation and default values.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// simple syntax</span></div><div class=\"line\">Vue.component(<span class=\"string\">'props-demo-simple'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'size'</span>, <span class=\"string\">'myMessage'</span>]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// object syntax with validation</span></div><div class=\"line\">Vue.component(<span class=\"string\">'props-demo-advanced'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// just type check</span></div><div class=\"line\">    height: <span class=\"built_in\">Number</span>,</div><div class=\"line\">    <span class=\"comment\">// type check plus other validations</span></div><div class=\"line\">    age: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">      <span class=\"attr\">default</span>: <span class=\"number\">0</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"attr\">validator</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value &gt;= <span class=\"number\">0</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Props\">Props</a></p>\n</li>\n</ul>\n<h3 id=\"propsData\"><a href=\"#propsData\" class=\"headerlink\" title=\"propsData\"></a>propsData</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: any }</code></p>\n</li>\n<li><p><strong>Restriction:</strong> only respected in instance creation via <code>new</code>.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Pass props to an instance during its creation. This is primarily intended to make unit testing easier.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Comp = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'msg'</span>],</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Comp(&#123;</div><div class=\"line\">  <span class=\"attr\">propsData</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">msg</span>: <span class=\"string\">'hello'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: Function | { get: Function, set: Function } }</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Computed properties to be mixed into the Vue instance. All getters and setters have their <code>this</code> context automatically bound to the Vue instance.</p>\n<p class=\"tip\">Note that <strong>you should not use an arrow function to define a computed property</strong> (e.g. <code>aDouble: () =&gt; this.a * 2</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.a</code> will be undefined.</p>\n\n<p>Computed properties are cached, and only re-computed on reactive dependency changes.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// get only, just need a function</span></div><div class=\"line\">    aDouble: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a * <span class=\"number\">2</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// both get and set</span></div><div class=\"line\">    aPlus: &#123;</div><div class=\"line\">      <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + <span class=\"number\">1</span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      <span class=\"attr\">set</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.a = v - <span class=\"number\">1</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.aPlus   <span class=\"comment\">// -&gt; 2</span></div><div class=\"line\">vm.aPlus = <span class=\"number\">3</span></div><div class=\"line\">vm.a       <span class=\"comment\">// -&gt; 2</span></div><div class=\"line\">vm.aDouble <span class=\"comment\">// -&gt; 4</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/computed.html\">Computed Properties</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their <code>this</code> context automatically bound to the Vue instance.</p>\n<p class=\"tip\">Note that <strong>you should not use an arrow function to define a method</strong> (e.g. <code>plus: () =&gt; this.a++</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.a</code> will be undefined.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">plus</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.a++</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.plus()</div><div class=\"line\">vm.a <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/events.html\">Methods and Event Handling</a></p>\n</li>\n</ul>\n<h3 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: string | Function | Object }</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>An object where keys are expressions to watch and values are the corresponding callbacks. The value can also be a string of a method name, or an Object that contains additional options. The Vue instance will call <code>$watch()</code> for each entry in the object at instantiation.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">b</span>: <span class=\"number\">2</span>,</div><div class=\"line\">    <span class=\"attr\">c</span>: <span class=\"number\">3</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val, oldVal</span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'new: %s, old: %s'</span>, val, oldVal)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// string method name</span></div><div class=\"line\">    b: <span class=\"string\">'someMethod'</span>,</div><div class=\"line\">    <span class=\"comment\">// deep watcher</span></div><div class=\"line\">    c: &#123;</div><div class=\"line\">      <span class=\"attr\">handler</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val, oldVal</span>) </span>&#123; <span class=\"comment\">/* ... */</span> &#125;,</div><div class=\"line\">      <span class=\"attr\">deep</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.a = <span class=\"number\">2</span> <span class=\"comment\">// -&gt; new: 2, old: 1</span></div></pre></td></tr></table></figure>\n<p class=\"tip\">Note that <strong>you should not use an arrow function to define a watcher</strong> (e.g. <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.updateAutocomplete</code> will be undefined.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#vm-watch\">Instance Methods - vm.$watch</a></p>\n</li>\n</ul>\n<h2 id=\"Options-DOM\"><a href=\"#Options-DOM\" class=\"headerlink\" title=\"Options / DOM\"></a>Options / DOM</h2><h3 id=\"el\"><a href=\"#el\" class=\"headerlink\" title=\"el\"></a>el</h3><ul>\n<li><p><strong>Type:</strong> <code>string | HTMLElement</code></p>\n</li>\n<li><p><strong>Restriction:</strong> only respected in instance creation via <code>new</code>.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.</p>\n<p>After the instance is mounted, the resolved element will be accessible as <code>vm.$el</code>.</p>\n<p>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call <code>vm.$mount()</code> to manually start the compilation.</p>\n<p class=\"tip\">The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to <code>&lt;html&gt;</code> or <code>&lt;body&gt;</code>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template\"></a>template</h3><ul>\n<li><p><strong>Type:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A string template to be used as the markup for the Vue instance. The template will <strong>replace</strong> the mounted element. Any existing markup inside the mounted element will be ignored, unless content distribution slots are present in the template.</p>\n<p>If the string starts with <code>#</code> it will be used as a querySelector and use the selected element’s innerHTML as the template string. This allows the use of the common <code>&lt;script type=&quot;x-template&quot;&gt;</code> trick to include templates.</p>\n<p class=\"tip\">From a security perspective, you should only use Vue templates that you can trust. Never use user-generated content as your template.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></li>\n<li><a href=\"../guide/components.html#Content-Distribution-with-Slots\">Content Distribution</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>An alternative to string templates allowing you to leverage the full programmatic power of JavaScript. The render function receives a <code>createElement</code> method as it’s first argument used to create <code>VNode</code>s.</p>\n<p>If the component is a functional component, the render function also receives an extra argument <code>context</code>, which provides access to contextual data since functional components are instance-less.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/render-function\">Render Functions</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Options-Lifecycle-Hooks\"><a href=\"#Options-Lifecycle-Hooks\" class=\"headerlink\" title=\"Options / Lifecycle Hooks\"></a>Options / Lifecycle Hooks</h2><p>All lifecycle hooks automatically have their <code>this</code> context bound to the instance, so that you can access data, computed properties, and methods. This means <strong>you should not use an arrow function to define a lifecycle method</strong> (e.g. <code>created: () =&gt; this.fetchTodos()</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.fetchTodos</code> will be undefined.</p>\n<h3 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called synchronously after the instance has just been initialized, before data observation and event/watcher setup.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called synchronously after the instance is created. At this stage, the instance has finished processing the options which means the following have been set up: data observation, computed properties, methods, watch/event callbacks. However, the mounting phase has not been started, and the <code>$el</code> property will not be available yet.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called right before the mounting begins: the <code>render</code> function is about to be called for the first time.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called after the instance has just been mounted where <code>el</code> is replaced by the newly created <code>vm.$el</code>. If the root instance is mounted to an in-document element, <code>vm.$el</code> will also be in-document when <code>mounted</code> is called.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called when the data changes, before the virtual DOM is re-rendered and patched.</p>\n<p>You can perform further state changes in this hook and they will not trigger additional re-renders.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called after a data change causes the virtual DOM to be re-rendered and patched.</p>\n<p>The component’s DOM will be in updated state when this hook is called, so you can perform DOM-dependent operations in this hook. However, in most cases you should avoid changing state in this hook, because it may lead to an infinite update loop.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"activated\"><a href=\"#activated\" class=\"headerlink\" title=\"activated\"></a>activated</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called when a kept-alive component is activated.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#keep-alive\">Built-in Components - keep-alive</a></li>\n<li><a href=\"../guide/components.html#keep-alive\">Dynamic Components - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"deactivated\"><a href=\"#deactivated\" class=\"headerlink\" title=\"deactivated\"></a>deactivated</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called when a kept-alive component is deactivated.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#keep-alive\">Built-in Components - keep-alive</a></li>\n<li><a href=\"../guide/components.html#keep-alive\">Dynamic Components - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called right before a Vue instance is destroyed. At this stage the instance is still fully functional.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called after a Vue instance has been destroyed. When this hook is called, all directives of the Vue instance have been unbound, all event listeners have been removed, and all child Vue instances have also been destroyed.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h2 id=\"Options-Assets\"><a href=\"#Options-Assets\" class=\"headerlink\" title=\"Options / Assets\"></a>Options / Assets</h2><h3 id=\"directives\"><a href=\"#directives\" class=\"headerlink\" title=\"directives\"></a>directives</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A hash of directives to be made available to the Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/custom-directive.html\">Custom Directives</a></li>\n<li><a href=\"../guide/components.html#Assets-Naming-Convention\">Assets Naming Convention</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"filters\"><a href=\"#filters\" class=\"headerlink\" title=\"filters\"></a>filters</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A hash of filters to be made available to the Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#Vue-filter\"><code>Vue.filter</code></a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"components\"><a href=\"#components\" class=\"headerlink\" title=\"components\"></a>components</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A hash of components to be made available to the Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/components.html\">Components</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Options-Misc\"><a href=\"#Options-Misc\" class=\"headerlink\" title=\"Options / Misc\"></a>Options / Misc</h2><h3 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent\"></a>parent</h3><ul>\n<li><p><strong>Type:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as <code>this.$parent</code> for the child, and the child will be pushed into the parent’s <code>$children</code> array.</p>\n<p class=\"tip\">Use <code>$parent</code> and <code>$children</code> sparringly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</p>\n\n</li>\n</ul>\n<h3 id=\"mixins\"><a href=\"#mixins\" class=\"headerlink\" title=\"mixins\"></a>mixins</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;Object&gt;</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The <code>mixins</code> option accepts an array of mixin objects. These mixin objects can contain instance options just like normal instance objects, and they will be merged against the eventual options using the same option merging logic in <code>Vue.extend()</code>. e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called.</p>\n<p>Mixin hooks are called in the order they are provided, and called before the component’s own hooks.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mixin = &#123;</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>) &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>) &#125;,</div><div class=\"line\">  <span class=\"attr\">mixins</span>: [mixin]</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// -&gt; 1</span></div><div class=\"line\"><span class=\"comment\">// -&gt; 2</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/mixins.html\">Mixins</a></p>\n</li>\n</ul>\n<h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><ul>\n<li><p><strong>Type:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Restriction:</strong> only respected when used as a component option.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Allow the component to recursively invoke itself in its template. Note that when a component is registered globally with <code>Vue.component()</code>, the global ID is automatically set as its name.</p>\n<p>Another benefit of specifying a <code>name</code> option is debugging. Named components result in more helpful warning messages. Also, when inspecting an app in the <a href=\"https://github.com/vuejs/vue-devtools\">vue-devtools</a>, unnamed components will show up as <code>&lt;AnonymousComponent&gt;</code>, which isn’t very informative. By providing the <code>name</code> option, you will get a much more informative component tree.</p>\n</li>\n</ul>\n<h3 id=\"extends\"><a href=\"#extends\" class=\"headerlink\" title=\"extends\"></a>extends</h3><ul>\n<li><p><strong>Type:</strong> <code>Object | Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Allows declaratively extending another component (could be either a plain options object or a constructor) without having to use <code>Vue.extend</code>. This is primarily intended to make it easier to extend between single file components.</p>\n<p>This is similar to <code>mixins</code>, the difference being that the component’s own options takes higher priority than the source component being extended.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CompA = &#123; ... &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// extend CompA without having to call Vue.extend on either</span></div><div class=\"line\"><span class=\"keyword\">var</span> CompB = &#123;</div><div class=\"line\">  <span class=\"attr\">extends</span>: CompA,</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"delimiters\"><a href=\"#delimiters\" class=\"headerlink\" title=\"delimiters\"></a>delimiters</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;string&gt;</code></p>\n</li>\n<li><p><strong>default:</strong> <code>[\"{{\", \"}}\"]</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Change the plain text interpolation delimiters. <strong>This option is only available in the standalone build.</strong></p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">delimiters</span>: [<span class=\"string\">'$&#123;'</span>, <span class=\"string\">'&#125;'</span>]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Delimiters changed to ES6 template string style</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"functional\"><a href=\"#functional\" class=\"headerlink\" title=\"functional\"></a>functional</h3><ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Causes a component to be stateless (no <code>data</code>) and instanceless (no <code>this</code> context). They are simply a <code>render</code> function that returns virtual nodes making them much cheaper to render.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/render-function.html#Functional-Components\">Functional Components</a></p>\n</li>\n</ul>\n<h2 id=\"Instance-Properties\"><a href=\"#Instance-Properties\" class=\"headerlink\" title=\"Instance Properties\"></a>Instance Properties</h2><h3 id=\"vm-data\"><a href=\"#vm-data\" class=\"headerlink\" title=\"vm.$data\"></a>vm.$data</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#data\">Options - data</a></p>\n</li>\n</ul>\n<h3 id=\"vm-el\"><a href=\"#vm-el\" class=\"headerlink\" title=\"vm.$el\"></a>vm.$el</h3><ul>\n<li><p><strong>Type:</strong> <code>HTMLElement</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The root DOM element that the Vue instance is managing.</p>\n</li>\n</ul>\n<h3 id=\"vm-options\"><a href=\"#vm-options\" class=\"headerlink\" title=\"vm.$options\"></a>vm.$options</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">customOption</span>: <span class=\"string\">'foo'</span>,</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.$options.customOption) <span class=\"comment\">// -&gt; 'foo'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"vm-parent\"><a href=\"#vm-parent\" class=\"headerlink\" title=\"vm.$parent\"></a>vm.$parent</h3><ul>\n<li><p><strong>Type:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The parent instance, if the current instance has one.</p>\n</li>\n</ul>\n<h3 id=\"vm-root\"><a href=\"#vm-root\" class=\"headerlink\" title=\"vm.$root\"></a>vm.$root</h3><ul>\n<li><p><strong>Type:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The root Vue instance of the current component tree. If the current instance has no parents this value will be itself.</p>\n</li>\n</ul>\n<h3 id=\"vm-children\"><a href=\"#vm-children\" class=\"headerlink\" title=\"vm.$children\"></a>vm.$children</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;Vue instance&gt;</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The direct child components of the current instance. <strong>Note there’s no order guarantee for <code>$children</code>, and it is not reactive.</strong> If you find yourself trying to use <code>$children</code> for data binding, consider using an Array and <code>v-for</code> to generate child components, and use the Array as the source of truth.</p>\n</li>\n</ul>\n<h3 id=\"vm-slots\"><a href=\"#vm-slots\" class=\"headerlink\" title=\"vm.$slots\"></a>vm.$slots</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Used to access content <a href=\"../guide/components.html#Content-Distribution-with-Slots\">distributed by slots</a>. Each <a href=\"../guide/components.html#Named-Slots\">named slot</a> has its own corresponding property (e.g. the contents of <code>slot=&quot;foo&quot;</code> will be found at <code>vm.$slots.foo</code>). The <code>default</code> property contains any nodes not included in a named slot.</p>\n<p>Accessing <code>vm.$slots</code> is most useful when writing a component with a <a href=\"../guide/render-function.html\">render function</a>.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">blog-post</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"header\"</span>&gt;</span></div><div class=\"line\">    About Me</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"footer\"</span>&gt;</span></div><div class=\"line\">    Copyright 2016 Evan You</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>If I have some content down here, it will also be included in vm.$slots.default.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>.</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'blog-post'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> header = <span class=\"keyword\">this</span>.$slots.header</div><div class=\"line\">    <span class=\"keyword\">var</span> body   = <span class=\"keyword\">this</span>.$slots.default</div><div class=\"line\">    <span class=\"keyword\">var</span> footer = <span class=\"keyword\">this</span>.$slots.footer</div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(<span class=\"string\">'div'</span>, [</div><div class=\"line\">      createElement(<span class=\"string\">'header'</span>, header)</div><div class=\"line\">      createElement(<span class=\"string\">'main'</span>, body)</div><div class=\"line\">      createElement(<span class=\"string\">'footer'</span>, footer)</div><div class=\"line\">    ])</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#slot\"><code>&lt;slot&gt;</code> Component</a></li>\n<li><a href=\"../guide/components.html#Content-Distribution-with-Slots\">Content Distribution with Slots</a></li>\n<li><a href=\"../guide/render-function.html\">Render Functions</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-refs\"><a href=\"#vm-refs\" class=\"headerlink\" title=\"vm.$refs\"></a>vm.$refs</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>An object that holds child components that have <code>ref</code> registered.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/components.html#Child-Component-Refs\">Child Component Refs</a></li>\n<li><a href=\"#ref\">ref</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-isServer\"><a href=\"#vm-isServer\" class=\"headerlink\" title=\"vm.$isServer\"></a>vm.$isServer</h3><ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Whether the current Vue instance is running on the server.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/ssr.html\">Server-Side Rendering</a></p>\n</li>\n</ul>\n<h2 id=\"Instance-Methods-Data\"><a href=\"#Instance-Methods-Data\" class=\"headerlink\" title=\"Instance Methods / Data\"></a>Instance Methods / Data</h2><h3 id=\"vm-watch\">vm.$watch( expOrFn, callback, [options] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string | Function} expOrFn</code></li>\n<li><code>{Function} callback</code></li>\n<li><code>{Object} [options]</code><ul>\n<li><code>{boolean} deep</code></li>\n<li><code>{boolean} immediate</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> <code>{Function} unwatch</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts simple dot-delimited paths. For more complex expression, use a function instead.</p>\n</li>\n</ul>\n<p class=\"tip\">Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn’t keep a copy of the pre-mutate value.</p>\n\n<ul>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// keypath</span></div><div class=\"line\">vm.$watch(<span class=\"string\">'a.b.c'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// function</span></div><div class=\"line\">vm.$watch(</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + <span class=\"keyword\">this</span>.b</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// do something</span></div><div class=\"line\">  &#125;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p><code>vm.$watch</code> returns an unwatch function that stops firing the callback:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> unwatch = vm.$watch(<span class=\"string\">'a'</span>, cb)</div><div class=\"line\"><span class=\"comment\">// later, teardown the watcher</span></div><div class=\"line\">unwatch()</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Option: deep</strong></p>\n<p>To also detect nested value changes inside Objects, you need to pass in <code>deep: true</code> in the options argument. Note that you don’t need to do so to listen for Array mutations.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vm.$watch(<span class=\"string\">'someObject'</span>, callback, &#123;</div><div class=\"line\">  <span class=\"attr\">deep</span>: <span class=\"literal\">true</span></div><div class=\"line\">&#125;)</div><div class=\"line\">vm.someObject.nestedValue = <span class=\"number\">123</span></div><div class=\"line\"><span class=\"comment\">// callback is fired</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Option: immediate</strong></p>\n<p>Passing in <code>immediate: true</code> in the option will trigger the callback immediately with the current value of the expression:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vm.$watch(<span class=\"string\">'a'</span>, callback, &#123;</div><div class=\"line\">  <span class=\"attr\">immediate</span>: <span class=\"literal\">true</span></div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// callback is fired immediately with current value of `a`</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"vm-set\">vm.$set( object, key, value )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> the set value.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>This is the <strong>alias</strong> of the global <code>Vue.set</code>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#Vue-set\">Vue.set</a></p>\n</li>\n</ul>\n<h3 id=\"vm-delete\">vm.$delete( object, key )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>This is the <strong>alias</strong> of the global <code>Vue.delete</code>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#Vue-delete\">Vue.delete</a></p>\n</li>\n</ul>\n<h2 id=\"Instance-Methods-Events\"><a href=\"#Instance-Methods-Events\" class=\"headerlink\" title=\"Instance Methods / Events\"></a>Instance Methods / Events</h2><h3 id=\"vm-on\">vm.$on( event, callback )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Listen for a custom event on the current vm. Events can be triggered by <code>vm.$emit</code>. The callback will receive all the additional arguments passed into these event-triggering methods.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vm.$on(<span class=\"string\">'test'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(msg)</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.$emit(<span class=\"string\">'test'</span>, <span class=\"string\">'hi'</span>)</div><div class=\"line\"><span class=\"comment\">// -&gt; \"hi\"</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"vm-once\">vm.$once( event, callback )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.</p>\n</li>\n</ul>\n<h3 id=\"vm-off\">vm.$off( [event, callback] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} [event]</code></li>\n<li><code>{Function} [callback]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Remove event listener(s).</p>\n<ul>\n<li><p>If no arguments are provided, remove all event listeners;</p>\n</li>\n<li><p>If only the event is provided, remove all listeners for that event;</p>\n</li>\n<li><p>If both event and callback are given, remove the listener for that specific callback only.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-emit\">vm.$emit( event, […args] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>[...args]</code></li>\n</ul>\n<p>Trigger an event on the current instance. Any additional arguments will be passed into the listener’s callback function.</p>\n</li>\n</ul>\n<h2 id=\"Instance-Methods-Lifecycle\"><a href=\"#Instance-Methods-Lifecycle\" class=\"headerlink\" title=\"Instance Methods / Lifecycle\"></a>Instance Methods / Lifecycle</h2><h3 id=\"vm-mount\">vm.$mount( [elementOrSelector] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Element | string} [elementOrSelector]</code></li>\n<li><code>{boolean} [hydrating]</code></li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> <code>vm</code> - the instance itself</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>If a Vue instance didn’t receive the <code>el</code> option at instantiation, it will be in “unmounted” state, without an associated DOM element. <code>vm.$mount()</code> can be used to manually start the mounting of an unmounted Vue instance.</p>\n<p>If <code>elementOrSelector</code> argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.</p>\n<p>The method returns the instance itself so you can chain other instance methods after it.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> MyComponent = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;Hello!&lt;/div&gt;'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// create and mount to #app (will replace #app)</span></div><div class=\"line\"><span class=\"keyword\">new</span> MyComponent().$mount(<span class=\"string\">'#app'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// the above is the same as:</span></div><div class=\"line\"><span class=\"keyword\">new</span> MyComponent(&#123; <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span> &#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// or, render off-document and append afterwards:</span></div><div class=\"line\"><span class=\"keyword\">var</span> component = <span class=\"keyword\">new</span> MyComponent().$mount()</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>).appendChild(component.$el)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></li>\n<li><a href=\"../guide/ssr.html\">Server-Side Rendering</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-forceUpdate\">vm.$forceUpdate()</h3>\n\n<ul>\n<li><p><strong>Usage:</strong></p>\n<p>Force the Vue instance to re-render. Note it does not affect all child components, only the instance itself and child components with inserted slot content.</p>\n</li>\n</ul>\n<h3 id=\"vm-nextTick\">vm.$nextTick( callback )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update. This is the same as the global <code>Vue.nextTick</code>, except that the callback’s <code>this</code> context is automatically bound to the instance calling this method.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    example: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// modify data</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.message = <span class=\"string\">'changed'</span></div><div class=\"line\">      <span class=\"comment\">// DOM is not updated yet</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// DOM is now updated</span></div><div class=\"line\">        <span class=\"comment\">// `this` is bound to the current instance</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.doSomethingElse()</div><div class=\"line\">      &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#Vue-nextTick\">Vue.nextTick</a></li>\n<li><a href=\"../guide/reactivity.html#Async-Update-Queue\">Async Update Queue</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-destroy\">vm.$destroy()</h3>\n\n<ul>\n<li><p><strong>Usage:</strong></p>\n<p>Completely destroy a vm. Clean up its connections with other existing vms, unbind all its directives, turn off all event listeners.</p>\n<p>Triggers the <code>beforeDestroy</code> and <code>destroyed</code> hooks.</p>\n<p class=\"tip\">In normal use cases you shouldn’t have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using <code>v-if</code> and <code>v-for</code>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h2 id=\"Directives\"><a href=\"#Directives\" class=\"headerlink\" title=\"Directives\"></a>Directives</h2><h3 id=\"v-text\"><a href=\"#v-text\" class=\"headerlink\" title=\"v-text\"></a>v-text</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Updates the element’s <code>textContent</code>. If you need to update the part of <code>textContent</code>, you should use <code>{{ Mustache }}</code> interpolations.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-text</span>=<span class=\"string\">\"msg\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- same as --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/syntax.html#Text\">Data Binding Syntax - interpolations</a></p>\n</li>\n</ul>\n<h3 id=\"v-html\"><a href=\"#v-html\" class=\"headerlink\" title=\"v-html\"></a>v-html</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Updates the element’s <code>innerHTML</code>. <strong>Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates</strong>. If you find yourself trying to compose templates using <code>v-html</code>, try to rethink the solution by using components instead.</p>\n<p class=\"tip\">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">XSS attacks</a>. Only use <code>v-html</code> on trusted content and <strong>never</strong> on user-provided content.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"html\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/syntax.html#Raw-HTML\">Data Binding Syntax - interpolations</a></p>\n</li>\n</ul>\n<h3 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a>v-if</h3><ul>\n<li><p><strong>Expects:</strong> <code>any</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Conditionally render the element based on the truthy-ness of the expression value. The element and its contained directives / components are destroyed and re-constructed during toggles. If the element is a <code>&lt;template&gt;</code> element, its content will be extracted as the conditional block.</p>\n<p>This directive triggers transitions when its condition changes.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/conditional.html\">Conditional Rendering - v-if</a></p>\n</li>\n</ul>\n<h3 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a>v-show</h3><ul>\n<li><p><strong>Expects:</strong> <code>any</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Toggle’s the element’s <code>display</code> CSS property based on the truthy-ness of the expression value.</p>\n<p>This directive triggers transitions when its condition changes.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/conditional.html#v-show\">Conditional Rendering - v-show</a></p>\n</li>\n</ul>\n<h3 id=\"v-else\"><a href=\"#v-else\" class=\"headerlink\" title=\"v-else\"></a>v-else</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Restriction:</strong> previous sibling element must have <code>v-if</code>.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Denote the “else block” for <code>v-if</code>.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"Math.random() &gt; 0.5\"</span>&gt;</span></div><div class=\"line\">  Now you see me</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else</span>&gt;</span></div><div class=\"line\">  Now you don't</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/conditional.html#v-else\">Conditional Rendering - v-else</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a>v-for</h3><ul>\n<li><p><strong>Expects:</strong> <code>Array | Object | number | string</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Render the element or template block multiple times based on the source data. The directive’s value must use the special syntax <code>alias in expression</code> to provide an alias for the current element being iterated on:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; item.text &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Alternatively, you can also specify an alias for the index (or the key if used on an Object):</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in items\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(val, key) in object\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(val, key, index) in object\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>The default behavior of <code>v-for</code> will try to patch the elements in-place without moving them. To force it to reorder elements, you need to provide an ordering hint with the <code>key</code> special attribute:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; item.text &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>The detailed usage for <code>v-for</code> is explained in the guide section linked below.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/list.html\">List Rendering</a></li>\n<li><a href=\"../guide/list.html#key\">key</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-on\"><a href=\"#v-on\" class=\"headerlink\" title=\"v-on\"></a>v-on</h3><ul>\n<li><p><strong>Shorthand:</strong> <code>@</code></p>\n</li>\n<li><p><strong>Expects:</strong> <code>Function | Inline Statement</code></p>\n</li>\n<li><p><strong>Argument:</strong> <code>event (required)</code></p>\n</li>\n<li><p><strong>Modifiers:</strong></p>\n<ul>\n<li><code>.stop</code> - call <code>event.stopPropagation()</code>.</li>\n<li><code>.prevent</code> - call <code>event.preventDefault()</code>.</li>\n<li><code>.capture</code> - add event listener in capture mode.</li>\n<li><code>.self</code> - only trigger handler if event was dispatched from this element.</li>\n<li><code>.{keyCode | keyAlias}</code> - only trigger handler on certain keys.</li>\n<li><code>.native</code> - listen for a native event on the root element of component.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Attaches an event listener to the element. The event type is denoted by the argument. The expression can either be a method name or an inline statement, or simply omitted when there are modifiers present.</p>\n<p>When used on a normal element, it listens to <strong>native DOM events</strong> only. When used on a custom element component, it also listens to <strong>custom events</strong> emitted on that child component.</p>\n<p>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special <code>$event</code> property: <code>v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;</code>.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- method handler --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- inline statement --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doThat('hello', $event)\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- shorthand --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- stop propagation --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.stop</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- prevent default --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.prevent</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- prevent default without expression --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> @<span class=\"attr\">submit.prevent</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- chain modifiers --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.stop.prevent</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- key modifier using keyAlias --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.enter</span>=<span class=\"string\">\"onEnter\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- key modifier using keyCode --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.13</span>=<span class=\"string\">\"onEnter\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Listening to custom events on a child component (the handler is called when “my-event” is emitted on the child):</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> @<span class=\"attr\">my-event</span>=<span class=\"string\">\"handleThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- inline statement --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> @<span class=\"attr\">my-event</span>=<span class=\"string\">\"handleThis(123, $event)\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- native event on component --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> @<span class=\"attr\">click.native</span>=<span class=\"string\">\"onClick\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/events.html\">Methods and Event Handling</a></li>\n<li><a href=\"../guide/components.html#Custom-Events\">Components - Custom Events</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-bind\"><a href=\"#v-bind\" class=\"headerlink\" title=\"v-bind\"></a>v-bind</h3><ul>\n<li><p><strong>Shorthand:</strong> <code>:</code></p>\n</li>\n<li><p><strong>Expects:</strong> <code>any (with argument) | Object (without argument)</code></p>\n</li>\n<li><p><strong>Argument:</strong> <code>attrOrProp (optional)</code></p>\n</li>\n<li><p><strong>Modifiers:</strong></p>\n<ul>\n<li><code>.prop</code> - Used for binding DOM attributes.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Dynamically bind one or more attributes, or a component prop to an expression.</p>\n<p>When used to bind the <code>class</code> or <code>style</code> attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.</p>\n<p>When used for prop binding, the prop must be properly declared in the child component.</p>\n<p>When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode <code>class</code> and <code>style</code> does not support Array or Objects.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- bind an attribute --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">v-bind:src</span>=<span class=\"string\">\"imageSrc\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- shorthand --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">:src</span>=<span class=\"string\">\"imageSrc\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- class binding --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:class</span>=<span class=\"string\">\"&#123; red: isRed &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:class</span>=<span class=\"string\">\"[classA, classB]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:class</span>=<span class=\"string\">\"[classA, &#123; classB: isB, classC: isC &#125;]\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- style binding --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123; fontSize: size + 'px' &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"[styleObjectA, styleObjectB]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- binding an object of attributes --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind</span>=<span class=\"string\">\"&#123; id: someProp, 'other-attr': otherProp &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- DOM attribute binding with prop modifier --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:text-content.prop</span>=<span class=\"string\">\"text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- prop binding. \"prop\" must be declared in my-component. --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">:prop</span>=<span class=\"string\">\"someThing\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- XLink --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">:xlink:special</span>=<span class=\"string\">\"foo\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/class-and-style.html\">Class and Style Bindings</a></li>\n<li><a href=\"../guide/components.html#Props\">Components - Component Props</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a>v-model</h3><ul>\n<li><p><strong>Expects:</strong> varies based on value of form inputs element or output of components</p>\n</li>\n<li><p><strong>Limited to:</strong></p>\n<ul>\n<li><code>&lt;input&gt;</code></li>\n<li><code>&lt;select&gt;</code></li>\n<li><code>&lt;textarea&gt;</code></li>\n<li>components</li>\n</ul>\n</li>\n<li><p><strong>Modifiers:</strong></p>\n<ul>\n<li><a href=\"../guide/forms.html#lazy\"><code>.lazy</code></a> - listen to <code>change</code> events instead of <code>input</code></li>\n<li><a href=\"../guide/forms.html#number\"><code>.number</code></a> - cast input string to numbers</li>\n<li><a href=\"/guild/forms.html#trim\"><code>.trim</code></a> - trim input</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Create a two-way binding on a form input element or a component. For detailed usage, see guide section linked below.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/forms.html\">Form Input Bindings</a></li>\n<li><a href=\"../guide/components.html#Form-Input-Components-using-Custom-Events\">Components - Form Input Components using Custom Events</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-pre\"><a href=\"#v-pre\" class=\"headerlink\" title=\"v-pre\"></a>v-pre</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-pre</span>&gt;</span>&#123;&#123; this will not be compiled &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"v-cloak\"><a href=\"#v-cloak\" class=\"headerlink\" title=\"v-cloak\"></a>v-cloak</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as <code>[v-cloak] { display: none }</code>, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-attr\">[v-cloak]</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: none;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-cloak</span>&gt;</span></div><div class=\"line\">  &#123;&#123; message &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>The <code>&lt;div&gt;</code> will not be visible until the compilation is done.</p>\n</li>\n</ul>\n<h3 id=\"v-once\"><a href=\"#v-once\" class=\"headerlink\" title=\"v-once\"></a>v-once</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Render the element and component <strong>once</strong> only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- single element --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-once</span>&gt;</span>This will never change: &#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- the element have children --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-once</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>comment<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- component --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-once</span> <span class=\"attr\">:comment</span>=<span class=\"string\">\"msg\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- v-for directive --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"i in list\"</span> <span class=\"attr\">v-once</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/syntax.html#Text\">Data Binding Syntax - interpolations</a></li>\n<li><a href=\"../guide/components.html#Cheap-Static-Components-with-v-once\">Components - Cheap Static Components with v-once</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Special-Attributes\"><a href=\"#Special-Attributes\" class=\"headerlink\" title=\"Special Attributes\"></a>Special Attributes</h2><h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n<p>The <code>key</code> special attribute is primarily used as a hint for Vue’s virtual DOM algorithm to identify VNodes when diffing the new list of nodes against the old list. Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed/destroyed.</p>\n<p>Children of the same common parent must have <strong>unique keys</strong>. Duplicate keys will cause render errors.</p>\n<p>The most common use case is combined with <code>v-for</code>:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:</p>\n<ul>\n<li>Properly trigger lifecycle hooks of a component</li>\n<li>Trigger transitions</li>\n</ul>\n<p>For example:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"text\"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>When <code>text</code> changes, the <code>&lt;span&gt;</code> will always be replaced instead of patched, so a transition will be triggered.</p>\n</li>\n</ul>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n<p><code>ref</code> is used to register a reference to an element or a child component. The reference will be registered under the parent component’s <code>$refs</code> object. If used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be component instance:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- vm.$refs.p will the DOM node --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"p\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- vm.$refs.child will be the child comp instance --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child-comp</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"child\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child-comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>When used on elements/components with <code>v-for</code>, the registered reference will be an Array containing DOM nodes or component instances.</p>\n<p>An important note about the ref registration timing: because the refs themselves are created as a result of the render function, you cannot access them on the initial render - they don’t exist yet! <code>$refs</code> is also non-reactive, therefore you should not attempt to use it in templates for data-binding.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Child-Component-Refs\">Child Component Refs</a></p>\n</li>\n</ul>\n<h3 id=\"slot\"><a href=\"#slot\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n<p>Used on content inserted into child components to indicate which named slot the content belongs to.</p>\n<p>For detailed usage, see the guide section linked below.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Named-Slots\">Named Slots</a></p>\n</li>\n</ul>\n<h2 id=\"Built-In-Components\"><a href=\"#Built-In-Components\" class=\"headerlink\" title=\"Built-In Components\"></a>Built-In Components</h2><h3 id=\"component\"><a href=\"#component\" class=\"headerlink\" title=\"component\"></a>component</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>is</code> - string | ComponentDefinition | ComponentConstructor</li>\n<li><code>inline-template</code> - boolean</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>A “meta component” for rendering dynamic components. The actual component to render is determined by the <code>is</code> prop:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- a dynamic component controlled by --&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- the `componentId` property on the vm --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"componentId\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- can also render registered component or component passed as prop --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"$options.components.child\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Dynamic-Components\">Dynamic Components</a></p>\n</li>\n</ul>\n<h3 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>name</code> - string, Used to automatically generate transition CSS class names. e.g. <code>name: &#39;fade&#39;</code> will auto expand to <code>.fade-enter</code>, <code>.fade-enter-active</code>, etc. Defaults to <code>&quot;v&quot;</code>.</li>\n<li><code>appear</code> - boolean, Whether to apply transition on initial render. Defaults to <code>false</code>.</li>\n<li><code>css</code> - boolean, Whether to apply CSS transition classes. Defaults to <code>true</code>. If set to <code>false</code>, will only trigger JavaScript hooks registered via component events.</li>\n<li><code>type</code> - string, Specify the type of transition events to wait for to determine transition end timing. Available values are <code>&quot;transition&quot;</code> and <code>&quot;animation&quot;</code>. By default, it will automatically detect the type that has a longer duration.</li>\n<li><code>mode</code> - string, Controls the timing sequence of leaving/entering transitions. Available modes are <code>&quot;out-in&quot;</code> and <code>&quot;in-out&quot;</code>; defaults to simultaneous.</li>\n<li><code>enter-class</code> - string</li>\n<li><code>leave-class</code> - string</li>\n<li><code>enter-active-class</code> - string</li>\n<li><code>leave-active-class</code> - string</li>\n<li><code>appear-class</code> - string</li>\n<li><code>appear-active-class</code> - string</li>\n</ul>\n</li>\n<li><p><strong>Events:</strong></p>\n<ul>\n<li><code>before-enter</code></li>\n<li><code>enter</code></li>\n<li><code>after-enter</code></li>\n<li><code>before-leave</code></li>\n<li><code>leave</code></li>\n<li><code>after-leave</code></li>\n<li><code>before-appear</code></li>\n<li><code>appear</code></li>\n<li><code>after-appear</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p><code>&lt;transition&gt;</code> serve as transition effects for <strong>single</strong> element/component. The <code>&lt;transition&gt;</code> does not render an extra DOM element, nor does it show up in the inspected component hierarchy. It simply applies the transition behavior to the wrapped content inside.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- simple element --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span>toggled content<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- dynamic component --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fade\"</span> <span class=\"attr\">mode</span>=<span class=\"string\">\"out-in\"</span> <span class=\"attr\">appear</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- event hooking --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transition-demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span> @<span class=\"attr\">after-enter</span>=<span class=\"string\">\"transitionComplete\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"ok\"</span>&gt;</span>toggled content<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    <span class=\"attr\">transitionComplete</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// for passed 'el' that DOM element as the argument, something ...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;).$mount(<span class=\"string\">'#transition-demo'</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/transitions.html\">Transitions: Entering, Leaving, and Lists</a></p>\n</li>\n</ul>\n<h3 id=\"transition-group\"><a href=\"#transition-group\" class=\"headerlink\" title=\"transition-group\"></a>transition-group</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>tag</code> - string, defaults to <code>span</code>.</li>\n<li><code>move-class</code> - overwrite CSS class applied during moving transition.</li>\n<li>exposes the same props as <code>&lt;transition&gt;</code> except <code>mode</code>.</li>\n</ul>\n</li>\n<li><p><strong>Events:</strong></p>\n<ul>\n<li>exposes the same events as <code>&lt;transition&gt;</code>.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p><code>&lt;transition-group&gt;</code> serve as transition effects for <strong>multiple</strong> elements/components. The <code>&lt;transition-group&gt;</code> renders a real DOM element. By default it renders a <code>&lt;span&gt;</code>, and you can configure what element is should render via the <code>tag</code> attribute.</p>\n<p>Note every child in a <code>&lt;transition-group&gt;</code> must be <strong>uniquely keyed</strong> for the animations to work properly.</p>\n<p><code>&lt;transition-group&gt;</code> supports moving transitions via CSS transform. When a child’s position on screen has changed after an updated, it will get applied a moving CSS class (auto generated from the <code>name</code> attribute or configured with the <code>move-class</code> attribute). If the CSS <code>transform</code> property is “transition-able” when the moving class is applied, the element will be smoothly animated to its destination using the <a href=\"https://aerotwist.com/blog/flip-your-animations/\">FLIP technique</a>.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition-group</span> <span class=\"attr\">tag</span>=<span class=\"string\">\"ul\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"slide\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; item.text &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/transitions.html\">Transitions: Entering, Leaving, and Lists</a></p>\n</li>\n</ul>\n<h3 id=\"keep-alive\"><a href=\"#keep-alive\" class=\"headerlink\" title=\"keep-alive\"></a>keep-alive</h3><ul>\n<li><p><strong>Usage:</strong></p>\n<p>When wrapped around a dynamic component, <code>&lt;keep-alive&gt;</code> caches the inactive component instances without destroying them. Similar to <code>&lt;transition&gt;</code>, <code>&lt;keep-alive&gt;</code> is an abstract component: it doesn’t render a DOM element itself, and doesn’t show up in the component parent chain.</p>\n<p>When a component is toggled inside <code>&lt;keep-alive&gt;</code>, its <code>activated</code> and <code>deactivated</code> lifecycle hooks will be invoked accordingly.</p>\n<p>Primarily used with preserve component state or avoid re-rendering.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- basic --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- multiple conditional children --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">comp-a</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"a &gt; 1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp-a</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">comp-b</span> <span class=\"attr\">v-else</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp-b</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- used together with &lt;transition&gt; --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p class=\"tip\"><code>&lt;keep-alive&gt;</code> does not work with functional components because they do not have instances to be cached.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#keep-alive\">Dynamic Components - keep-alive</a></p>\n</li>\n</ul>\n<h3 id=\"slot-1\"><a href=\"#slot-1\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>name</code> - string, Used for named slot.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p><code>&lt;slot&gt;</code> serve as content distribution outlets in component templates. <code>&lt;slot&gt;</code> itself will be replaced.</p>\n<p>For detailed usage, see the guide section linked below.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Content-Distribution-with-Slots\">Content Distribution with Slots</a></p>\n</li>\n</ul>\n<h2 id=\"VNode-Interface\"><a href=\"#VNode-Interface\" class=\"headerlink\" title=\"VNode Interface\"></a>VNode Interface</h2><ul>\n<li>Please refer to the <a href=\"https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js\">VNode class declaration</a>.</li>\n</ul>\n<h2 id=\"Server-Side-Rendering\"><a href=\"#Server-Side-Rendering\" class=\"headerlink\" title=\"Server-Side Rendering\"></a>Server-Side Rendering</h2><ul>\n<li>Please refer to the <a href=\"https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer\">vue-server-renderer package documentation</a>.<br>–&gt;</li>\n</ul>\n-->","excerpt":"","more":"<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p><strong>Zman</strong> is a PHP package that makes Jewish date conversions simple and easy.</p>\n<p>The <code>Zman</code> class is inherited from the amazing <a href=\"https://github.com/briannesbitt/Carbon\">briannesbitt/Carbon</a> which in turn inherits from PHP’s <a href=\"http://www.php.net/manual/en/class.datetime.php\">DateTime</a> class, thus giving us access to some pretty nifty methods.</p>\n<h2 id=\"Instantiation\"><a href=\"#Instantiation\" class=\"headerlink\" title=\"Instantiation\"></a>Instantiation</h2><p>There are three different ways to create a new instance of <code>Zman</code>.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><div class=\"line\">$zman = <span class=\"keyword\">new</span> Zman(<span class=\"string\">'first day of November 2016'</span>);</div><div class=\"line\">$zman = Zman::parse(<span class=\"string\">'first day of November 2016'</span>);</div><div class=\"line\">$zman = Zman::now();</div></pre></td></tr></table></figure>\n<!-- \n\n### silent\n\n- **Type:** `boolean`\n\n- **Default:** `false`\n\n- **Usage:**\n\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.silent = <span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<p>  Suppress all Vue logs and warnings.</p>\n<h3 id=\"optionMergeStrategies\"><a href=\"#optionMergeStrategies\" class=\"headerlink\" title=\"optionMergeStrategies\"></a>optionMergeStrategies</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>{}</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.optionMergeStrategies._my_option = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">parent, child, vm</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> child + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> Profile = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">_my_option</span>: <span class=\"number\">1</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Profile.options._my_option = 2</span></div></pre></td></tr></table></figure>\n<p>Define custom merging strategies for options.</p>\n<p>The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/mixins.html#Custom-Option-Merge-Strategies\">Custom Option Merging Strategies</a></p>\n</li>\n</ul>\n<h3 id=\"devtools\"><a href=\"#devtools\" class=\"headerlink\" title=\"devtools\"></a>devtools</h3><ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>true</code> (<code>false</code> in production builds)</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// make sure to set this synchronously immediately after loading Vue</span></div><div class=\"line\">Vue.config.devtools = <span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<p>Configure whether to allow <a href=\"https://github.com/vuejs/vue-devtools\">vue-devtools</a> inspection. This option’s default value is <code>true</code> in development builds and <code>false</code> in production builds. You can set it to <code>true</code> to enable inspection for production builds.</p>\n</li>\n</ul>\n<h3 id=\"errorHandler\"><a href=\"#errorHandler\" class=\"headerlink\" title=\"errorHandler\"></a>errorHandler</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Default:</strong> Error is thrown in place</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.errorHandler = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, vm</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// handle error</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Assign a handler for uncaught errors during component render and watchers. The handler gets called with the error and the Vue instance.</p>\n<blockquote>\n<p><a href=\"https://sentry.io\">Sentry</a>, an error tracking service, provides <a href=\"https://sentry.io/for/vue/\">official integration</a> using this option.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"ignoredElements\"><a href=\"#ignoredElements\" class=\"headerlink\" title=\"ignoredElements\"></a>ignoredElements</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;string&gt;</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>[]</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.ignoredElements = [</div><div class=\"line\">  <span class=\"string\">'my-custom-web-component'</span>, <span class=\"string\">'another-web-component'</span></div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<p>Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an <code>Unknown custom element</code>, assuming that you forgot to register a global component or misspelled a component name.</p>\n</li>\n</ul>\n<h3 id=\"keyCodes\"><a href=\"#keyCodes\" class=\"headerlink\" title=\"keyCodes\"></a>keyCodes</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: number }</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>{}</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.config.keyCodes = &#123;</div><div class=\"line\">  <span class=\"attr\">v</span>: <span class=\"number\">86</span>,</div><div class=\"line\">  <span class=\"attr\">f1</span>: <span class=\"number\">112</span>,</div><div class=\"line\">  <span class=\"attr\">mediaPlayPause</span>: <span class=\"number\">179</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Define custom key alias(es) for v-on.</p>\n</li>\n</ul>\n<h2 id=\"Global-API\"><a href=\"#Global-API\" class=\"headerlink\" title=\"Global API\"></a>Global API</h2><h3 id=\"Vue-extend\">Vue.extend( options )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} options</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Create a “subclass” of the base Vue constructor. The argument should be an object containing component options.</p>\n<p>The special case to note here is the <code>data</code> option - it must be a function when used with <code>Vue.extend()</code>.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mount-point\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// create constructor</span></div><div class=\"line\"><span class=\"keyword\">var</span> Profile = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      <span class=\"attr\">firstName</span>: <span class=\"string\">'Walter'</span>,</div><div class=\"line\">      <span class=\"attr\">lastName</span>: <span class=\"string\">'White'</span>,</div><div class=\"line\">      <span class=\"attr\">alias</span>: <span class=\"string\">'Heisenberg'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// create an instance of Profile and mount it on an element</span></div><div class=\"line\"><span class=\"keyword\">new</span> Profile().$mount(<span class=\"string\">'#mount-point'</span>)</div></pre></td></tr></table></figure>\n<p>Will result in:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Walter White aka Heisenberg<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html\">Components</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-nextTick\">Vue.nextTick( callback, [context] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Function} callback</code></li>\n<li><code>{Object} [context]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// modify data</span></div><div class=\"line\">vm.msg = <span class=\"string\">'Hello'</span></div><div class=\"line\"><span class=\"comment\">// DOM not updated yet</span></div><div class=\"line\">Vue.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// DOM updated</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html#Async-Update-Queue\">Async Update Queue</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-set\">Vue.set( object, key, value )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> the set value.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Set a property on an object. If the object is reactive, ensure the property is created as a reactive property and trigger view updates. This is primarily used to get around the limitation that Vue cannot detect property additions.</p>\n<p><strong>Note the object cannot be a Vue instance, or the root data object of a Vue instance.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html\">Reactivity in Depth</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-delete\">Vue.delete( object, key )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates. This is primarily used to get around the limitation that Vue cannot detect property deletions, but you should rarely need to use it.</p>\n<p><strong>Note the object cannot be a Vue instance, or the root data object of a Vue instance.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html\">Reactivity in Depth</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-directive\">Vue.directive( id, [definition] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Register or retrieve a global directive.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// register</span></div><div class=\"line\">Vue.directive(<span class=\"string\">'my-directive'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">bind</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">inserted</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">update</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">componentUpdated</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  <span class=\"attr\">unbind</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// register (simple function directive)</span></div><div class=\"line\">Vue.directive(<span class=\"string\">'my-directive'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// this will be called as `bind` and `update`</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getter, return the directive definition if registered</span></div><div class=\"line\"><span class=\"keyword\">var</span> myDirective = Vue.directive(<span class=\"string\">'my-directive'</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/custom-directive.html\">Custom Directives</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-filter\">Vue.filter( id, [definition] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Register or retrieve a global filter.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// register</span></div><div class=\"line\">Vue.filter(<span class=\"string\">'my-filter'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// return processed value</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getter, return the filter if registered</span></div><div class=\"line\"><span class=\"keyword\">var</span> myFilter = Vue.filter(<span class=\"string\">'my-filter'</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Vue-component\">Vue.component( id, [definition] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Register or retrieve a global component. Registration also automatically sets the component’s <code>name</code> with the given <code>id</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// register an extended constructor</span></div><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, Vue.extend(&#123; <span class=\"comment\">/* ... */</span> &#125;))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// register an options object (automatically call Vue.extend)</span></div><div class=\"line\">Vue.component(<span class=\"string\">'my-component'</span>, &#123; <span class=\"comment\">/* ... */</span> &#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// retrieve a registered component (always return constructor)</span></div><div class=\"line\"><span class=\"keyword\">var</span> MyComponent = Vue.component(<span class=\"string\">'my-component'</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html\">Components</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-use\">Vue.use( plugin )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object | Function} plugin</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Install a Vue.js plugin. If the plugin is an Object, it must expose an <code>install</code> method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.</p>\n<p>When this method is called on the same plugin multiple times, the plugin will be installed only once.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/plugins.html\">Plugins</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-mixin\">Vue.mixin( mixin )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} mixin</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Apply a mixin globally, which affects every Vue instance created afterwards. This can be used by plugin authors to inject custom behavior into components. <strong>Not recommended in application code</strong>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/mixins.html#Global-Mixin\">Global Mixins</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-compile\">Vue.compile( template )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} template</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Compiles a template string into a render function. <strong>Only available in the standalone build.</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> res = Vue.compile(<span class=\"string\">'&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">msg</span>: <span class=\"string\">'hello'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">render</span>: res.render,</div><div class=\"line\">  <span class=\"attr\">staticRenderFns</span>: res.staticRenderFns</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/render-function.html\">Render Functions</a></p>\n</li>\n</ul>\n<h2 id=\"Options-Data\"><a href=\"#Options-Data\" class=\"headerlink\" title=\"Options / Data\"></a>Options / Data</h2><h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><ul>\n<li><p><strong>Type:</strong> <code>Object | Function</code></p>\n</li>\n<li><p><strong>Restriction:</strong> Only accepts <code>Function</code> when used in a component definition.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it “reactive”. <strong>The object must be plain</strong>: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with its own stateful behavior.</p>\n<p>Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.</p>\n<p>After the instance is created, the original data object can be accessed as <code>vm.$data</code>. The Vue instance also proxies all the properties found on the data object, so <code>vm.a</code> will be equivalent to <code>vm.$data.a</code>.</p>\n<p>Properties that start with <code>_</code> or <code>$</code> will <strong>not</strong> be proxied on the Vue instance because they may conflict with Vue’s internal properties and API methods. You will have to access them as <code>vm.$data._property</code>.</p>\n<p>When defining a <strong>component</strong>, <code>data</code> must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we still use a plain object for <code>data</code>, that same object will be <strong>shared by reference</strong> across all instances created! By providing a <code>data</code> function, every time a new instance is created, we can simply call it to return a fresh copy of the initial data.</p>\n<p>If required, a deep clone of the original object can be obtained by passing <code>vm.$data</code> through <code>JSON.parse(JSON.stringify(...))</code>.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// direct instance creation</span></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: data</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.a <span class=\"comment\">// -&gt; 1</span></div><div class=\"line\">vm.$data === data <span class=\"comment\">// -&gt; true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// must use function when in Vue.extend()</span></div><div class=\"line\"><span class=\"keyword\">var</span> Component = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p class=\"tip\">Note that <strong>you should not use an arrow function with the <code>data</code> property</strong> (e.g. <code>data: () =&gt; { return { a: this.myProp }}</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.myProp</code> will be undefined.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html\">Reactivity in Depth</a></p>\n</li>\n</ul>\n<h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;string&gt; | Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A list/hash of attributes that are exposed to accept data from the parent component. It has a simple Array-based syntax and an alternative Object-based syntax that allows advanced configurations such as type checking, custom validation and default values.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// simple syntax</span></div><div class=\"line\">Vue.component(<span class=\"string\">'props-demo-simple'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'size'</span>, <span class=\"string\">'myMessage'</span>]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// object syntax with validation</span></div><div class=\"line\">Vue.component(<span class=\"string\">'props-demo-advanced'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// just type check</span></div><div class=\"line\">    height: <span class=\"built_in\">Number</span>,</div><div class=\"line\">    <span class=\"comment\">// type check plus other validations</span></div><div class=\"line\">    age: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">      <span class=\"attr\">default</span>: <span class=\"number\">0</span>,</div><div class=\"line\">      <span class=\"attr\">required</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"attr\">validator</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value &gt;= <span class=\"number\">0</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Props\">Props</a></p>\n</li>\n</ul>\n<h3 id=\"propsData\"><a href=\"#propsData\" class=\"headerlink\" title=\"propsData\"></a>propsData</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: any }</code></p>\n</li>\n<li><p><strong>Restriction:</strong> only respected in instance creation via <code>new</code>.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Pass props to an instance during its creation. This is primarily intended to make unit testing easier.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Comp = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'msg'</span>],</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Comp(&#123;</div><div class=\"line\">  <span class=\"attr\">propsData</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">msg</span>: <span class=\"string\">'hello'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: Function | { get: Function, set: Function } }</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Computed properties to be mixed into the Vue instance. All getters and setters have their <code>this</code> context automatically bound to the Vue instance.</p>\n<p class=\"tip\">Note that <strong>you should not use an arrow function to define a computed property</strong> (e.g. <code>aDouble: () =&gt; this.a * 2</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.a</code> will be undefined.</p>\n\n<p>Computed properties are cached, and only re-computed on reactive dependency changes.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;,</div><div class=\"line\">  <span class=\"attr\">computed</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// get only, just need a function</span></div><div class=\"line\">    aDouble: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a * <span class=\"number\">2</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// both get and set</span></div><div class=\"line\">    aPlus: &#123;</div><div class=\"line\">      <span class=\"attr\">get</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + <span class=\"number\">1</span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      <span class=\"attr\">set</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.a = v - <span class=\"number\">1</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.aPlus   <span class=\"comment\">// -&gt; 2</span></div><div class=\"line\">vm.aPlus = <span class=\"number\">3</span></div><div class=\"line\">vm.a       <span class=\"comment\">// -&gt; 2</span></div><div class=\"line\">vm.aDouble <span class=\"comment\">// -&gt; 4</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/computed.html\">Computed Properties</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their <code>this</code> context automatically bound to the Vue instance.</p>\n<p class=\"tip\">Note that <strong>you should not use an arrow function to define a method</strong> (e.g. <code>plus: () =&gt; this.a++</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.a</code> will be undefined.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;,</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">plus</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.a++</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.plus()</div><div class=\"line\">vm.a <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/events.html\">Methods and Event Handling</a></p>\n</li>\n</ul>\n<h3 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: string | Function | Object }</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>An object where keys are expressions to watch and values are the corresponding callbacks. The value can also be a string of a method name, or an Object that contains additional options. The Vue instance will call <code>$watch()</code> for each entry in the object at instantiation.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">b</span>: <span class=\"number\">2</span>,</div><div class=\"line\">    <span class=\"attr\">c</span>: <span class=\"number\">3</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val, oldVal</span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'new: %s, old: %s'</span>, val, oldVal)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// string method name</span></div><div class=\"line\">    b: <span class=\"string\">'someMethod'</span>,</div><div class=\"line\">    <span class=\"comment\">// deep watcher</span></div><div class=\"line\">    c: &#123;</div><div class=\"line\">      <span class=\"attr\">handler</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val, oldVal</span>) </span>&#123; <span class=\"comment\">/* ... */</span> &#125;,</div><div class=\"line\">      <span class=\"attr\">deep</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.a = <span class=\"number\">2</span> <span class=\"comment\">// -&gt; new: 2, old: 1</span></div></pre></td></tr></table></figure>\n<p class=\"tip\">Note that <strong>you should not use an arrow function to define a watcher</strong> (e.g. <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.updateAutocomplete</code> will be undefined.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#vm-watch\">Instance Methods - vm.$watch</a></p>\n</li>\n</ul>\n<h2 id=\"Options-DOM\"><a href=\"#Options-DOM\" class=\"headerlink\" title=\"Options / DOM\"></a>Options / DOM</h2><h3 id=\"el\"><a href=\"#el\" class=\"headerlink\" title=\"el\"></a>el</h3><ul>\n<li><p><strong>Type:</strong> <code>string | HTMLElement</code></p>\n</li>\n<li><p><strong>Restriction:</strong> only respected in instance creation via <code>new</code>.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.</p>\n<p>After the instance is mounted, the resolved element will be accessible as <code>vm.$el</code>.</p>\n<p>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call <code>vm.$mount()</code> to manually start the compilation.</p>\n<p class=\"tip\">The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to <code>&lt;html&gt;</code> or <code>&lt;body&gt;</code>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template\"></a>template</h3><ul>\n<li><p><strong>Type:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A string template to be used as the markup for the Vue instance. The template will <strong>replace</strong> the mounted element. Any existing markup inside the mounted element will be ignored, unless content distribution slots are present in the template.</p>\n<p>If the string starts with <code>#</code> it will be used as a querySelector and use the selected element’s innerHTML as the template string. This allows the use of the common <code>&lt;script type=&quot;x-template&quot;&gt;</code> trick to include templates.</p>\n<p class=\"tip\">From a security perspective, you should only use Vue templates that you can trust. Never use user-generated content as your template.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></li>\n<li><a href=\"../guide/components.html#Content-Distribution-with-Slots\">Content Distribution</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>An alternative to string templates allowing you to leverage the full programmatic power of JavaScript. The render function receives a <code>createElement</code> method as it’s first argument used to create <code>VNode</code>s.</p>\n<p>If the component is a functional component, the render function also receives an extra argument <code>context</code>, which provides access to contextual data since functional components are instance-less.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/render-function\">Render Functions</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Options-Lifecycle-Hooks\"><a href=\"#Options-Lifecycle-Hooks\" class=\"headerlink\" title=\"Options / Lifecycle Hooks\"></a>Options / Lifecycle Hooks</h2><p>All lifecycle hooks automatically have their <code>this</code> context bound to the instance, so that you can access data, computed properties, and methods. This means <strong>you should not use an arrow function to define a lifecycle method</strong> (e.g. <code>created: () =&gt; this.fetchTodos()</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.fetchTodos</code> will be undefined.</p>\n<h3 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called synchronously after the instance has just been initialized, before data observation and event/watcher setup.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called synchronously after the instance is created. At this stage, the instance has finished processing the options which means the following have been set up: data observation, computed properties, methods, watch/event callbacks. However, the mounting phase has not been started, and the <code>$el</code> property will not be available yet.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called right before the mounting begins: the <code>render</code> function is about to be called for the first time.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called after the instance has just been mounted where <code>el</code> is replaced by the newly created <code>vm.$el</code>. If the root instance is mounted to an in-document element, <code>vm.$el</code> will also be in-document when <code>mounted</code> is called.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called when the data changes, before the virtual DOM is re-rendered and patched.</p>\n<p>You can perform further state changes in this hook and they will not trigger additional re-renders.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called after a data change causes the virtual DOM to be re-rendered and patched.</p>\n<p>The component’s DOM will be in updated state when this hook is called, so you can perform DOM-dependent operations in this hook. However, in most cases you should avoid changing state in this hook, because it may lead to an infinite update loop.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"activated\"><a href=\"#activated\" class=\"headerlink\" title=\"activated\"></a>activated</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called when a kept-alive component is activated.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#keep-alive\">Built-in Components - keep-alive</a></li>\n<li><a href=\"../guide/components.html#keep-alive\">Dynamic Components - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"deactivated\"><a href=\"#deactivated\" class=\"headerlink\" title=\"deactivated\"></a>deactivated</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called when a kept-alive component is deactivated.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#keep-alive\">Built-in Components - keep-alive</a></li>\n<li><a href=\"../guide/components.html#keep-alive\">Dynamic Components - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called right before a Vue instance is destroyed. At this stage the instance is still fully functional.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called after a Vue instance has been destroyed. When this hook is called, all directives of the Vue instance have been unbound, all event listeners have been removed, and all child Vue instances have also been destroyed.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h2 id=\"Options-Assets\"><a href=\"#Options-Assets\" class=\"headerlink\" title=\"Options / Assets\"></a>Options / Assets</h2><h3 id=\"directives\"><a href=\"#directives\" class=\"headerlink\" title=\"directives\"></a>directives</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A hash of directives to be made available to the Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/custom-directive.html\">Custom Directives</a></li>\n<li><a href=\"../guide/components.html#Assets-Naming-Convention\">Assets Naming Convention</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"filters\"><a href=\"#filters\" class=\"headerlink\" title=\"filters\"></a>filters</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A hash of filters to be made available to the Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#Vue-filter\"><code>Vue.filter</code></a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"components\"><a href=\"#components\" class=\"headerlink\" title=\"components\"></a>components</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A hash of components to be made available to the Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/components.html\">Components</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Options-Misc\"><a href=\"#Options-Misc\" class=\"headerlink\" title=\"Options / Misc\"></a>Options / Misc</h2><h3 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent\"></a>parent</h3><ul>\n<li><p><strong>Type:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as <code>this.$parent</code> for the child, and the child will be pushed into the parent’s <code>$children</code> array.</p>\n<p class=\"tip\">Use <code>$parent</code> and <code>$children</code> sparringly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</p>\n\n</li>\n</ul>\n<h3 id=\"mixins\"><a href=\"#mixins\" class=\"headerlink\" title=\"mixins\"></a>mixins</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;Object&gt;</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The <code>mixins</code> option accepts an array of mixin objects. These mixin objects can contain instance options just like normal instance objects, and they will be merged against the eventual options using the same option merging logic in <code>Vue.extend()</code>. e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called.</p>\n<p>Mixin hooks are called in the order they are provided, and called before the component’s own hooks.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mixin = &#123;</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>) &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>) &#125;,</div><div class=\"line\">  <span class=\"attr\">mixins</span>: [mixin]</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// -&gt; 1</span></div><div class=\"line\"><span class=\"comment\">// -&gt; 2</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/mixins.html\">Mixins</a></p>\n</li>\n</ul>\n<h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><ul>\n<li><p><strong>Type:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Restriction:</strong> only respected when used as a component option.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Allow the component to recursively invoke itself in its template. Note that when a component is registered globally with <code>Vue.component()</code>, the global ID is automatically set as its name.</p>\n<p>Another benefit of specifying a <code>name</code> option is debugging. Named components result in more helpful warning messages. Also, when inspecting an app in the <a href=\"https://github.com/vuejs/vue-devtools\">vue-devtools</a>, unnamed components will show up as <code>&lt;AnonymousComponent&gt;</code>, which isn’t very informative. By providing the <code>name</code> option, you will get a much more informative component tree.</p>\n</li>\n</ul>\n<h3 id=\"extends\"><a href=\"#extends\" class=\"headerlink\" title=\"extends\"></a>extends</h3><ul>\n<li><p><strong>Type:</strong> <code>Object | Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Allows declaratively extending another component (could be either a plain options object or a constructor) without having to use <code>Vue.extend</code>. This is primarily intended to make it easier to extend between single file components.</p>\n<p>This is similar to <code>mixins</code>, the difference being that the component’s own options takes higher priority than the source component being extended.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CompA = &#123; ... &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// extend CompA without having to call Vue.extend on either</span></div><div class=\"line\"><span class=\"keyword\">var</span> CompB = &#123;</div><div class=\"line\">  <span class=\"attr\">extends</span>: CompA,</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"delimiters\"><a href=\"#delimiters\" class=\"headerlink\" title=\"delimiters\"></a>delimiters</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;string&gt;</code></p>\n</li>\n<li><p><strong>default:</strong> <code>[\"{{\", \"}}\"]</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Change the plain text interpolation delimiters. <strong>This option is only available in the standalone build.</strong></p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">delimiters</span>: [<span class=\"string\">'$&#123;'</span>, <span class=\"string\">'&#125;'</span>]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Delimiters changed to ES6 template string style</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"functional\"><a href=\"#functional\" class=\"headerlink\" title=\"functional\"></a>functional</h3><ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Causes a component to be stateless (no <code>data</code>) and instanceless (no <code>this</code> context). They are simply a <code>render</code> function that returns virtual nodes making them much cheaper to render.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/render-function.html#Functional-Components\">Functional Components</a></p>\n</li>\n</ul>\n<h2 id=\"Instance-Properties\"><a href=\"#Instance-Properties\" class=\"headerlink\" title=\"Instance Properties\"></a>Instance Properties</h2><h3 id=\"vm-data\"><a href=\"#vm-data\" class=\"headerlink\" title=\"vm.$data\"></a>vm.$data</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#data\">Options - data</a></p>\n</li>\n</ul>\n<h3 id=\"vm-el\"><a href=\"#vm-el\" class=\"headerlink\" title=\"vm.$el\"></a>vm.$el</h3><ul>\n<li><p><strong>Type:</strong> <code>HTMLElement</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The root DOM element that the Vue instance is managing.</p>\n</li>\n</ul>\n<h3 id=\"vm-options\"><a href=\"#vm-options\" class=\"headerlink\" title=\"vm.$options\"></a>vm.$options</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">customOption</span>: <span class=\"string\">'foo'</span>,</div><div class=\"line\">  <span class=\"attr\">created</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.$options.customOption) <span class=\"comment\">// -&gt; 'foo'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"vm-parent\"><a href=\"#vm-parent\" class=\"headerlink\" title=\"vm.$parent\"></a>vm.$parent</h3><ul>\n<li><p><strong>Type:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The parent instance, if the current instance has one.</p>\n</li>\n</ul>\n<h3 id=\"vm-root\"><a href=\"#vm-root\" class=\"headerlink\" title=\"vm.$root\"></a>vm.$root</h3><ul>\n<li><p><strong>Type:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The root Vue instance of the current component tree. If the current instance has no parents this value will be itself.</p>\n</li>\n</ul>\n<h3 id=\"vm-children\"><a href=\"#vm-children\" class=\"headerlink\" title=\"vm.$children\"></a>vm.$children</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;Vue instance&gt;</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The direct child components of the current instance. <strong>Note there’s no order guarantee for <code>$children</code>, and it is not reactive.</strong> If you find yourself trying to use <code>$children</code> for data binding, consider using an Array and <code>v-for</code> to generate child components, and use the Array as the source of truth.</p>\n</li>\n</ul>\n<h3 id=\"vm-slots\"><a href=\"#vm-slots\" class=\"headerlink\" title=\"vm.$slots\"></a>vm.$slots</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Used to access content <a href=\"../guide/components.html#Content-Distribution-with-Slots\">distributed by slots</a>. Each <a href=\"../guide/components.html#Named-Slots\">named slot</a> has its own corresponding property (e.g. the contents of <code>slot=&quot;foo&quot;</code> will be found at <code>vm.$slots.foo</code>). The <code>default</code> property contains any nodes not included in a named slot.</p>\n<p>Accessing <code>vm.$slots</code> is most useful when writing a component with a <a href=\"../guide/render-function.html\">render function</a>.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">blog-post</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"header\"</span>&gt;</span></div><div class=\"line\">    About Me</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"footer\"</span>&gt;</span></div><div class=\"line\">    Copyright 2016 Evan You</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>If I have some content down here, it will also be included in vm.$slots.default.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>.</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">blog-post</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'blog-post'</span>, &#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">createElement</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> header = <span class=\"keyword\">this</span>.$slots.header</div><div class=\"line\">    <span class=\"keyword\">var</span> body   = <span class=\"keyword\">this</span>.$slots.default</div><div class=\"line\">    <span class=\"keyword\">var</span> footer = <span class=\"keyword\">this</span>.$slots.footer</div><div class=\"line\">    <span class=\"keyword\">return</span> createElement(<span class=\"string\">'div'</span>, [</div><div class=\"line\">      createElement(<span class=\"string\">'header'</span>, header)</div><div class=\"line\">      createElement(<span class=\"string\">'main'</span>, body)</div><div class=\"line\">      createElement(<span class=\"string\">'footer'</span>, footer)</div><div class=\"line\">    ])</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#slot\"><code>&lt;slot&gt;</code> Component</a></li>\n<li><a href=\"../guide/components.html#Content-Distribution-with-Slots\">Content Distribution with Slots</a></li>\n<li><a href=\"../guide/render-function.html\">Render Functions</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-refs\"><a href=\"#vm-refs\" class=\"headerlink\" title=\"vm.$refs\"></a>vm.$refs</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>An object that holds child components that have <code>ref</code> registered.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/components.html#Child-Component-Refs\">Child Component Refs</a></li>\n<li><a href=\"#ref\">ref</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-isServer\"><a href=\"#vm-isServer\" class=\"headerlink\" title=\"vm.$isServer\"></a>vm.$isServer</h3><ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Whether the current Vue instance is running on the server.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/ssr.html\">Server-Side Rendering</a></p>\n</li>\n</ul>\n<h2 id=\"Instance-Methods-Data\"><a href=\"#Instance-Methods-Data\" class=\"headerlink\" title=\"Instance Methods / Data\"></a>Instance Methods / Data</h2><h3 id=\"vm-watch\">vm.$watch( expOrFn, callback, [options] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string | Function} expOrFn</code></li>\n<li><code>{Function} callback</code></li>\n<li><code>{Object} [options]</code><ul>\n<li><code>{boolean} deep</code></li>\n<li><code>{boolean} immediate</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> <code>{Function} unwatch</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts simple dot-delimited paths. For more complex expression, use a function instead.</p>\n</li>\n</ul>\n<p class=\"tip\">Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn’t keep a copy of the pre-mutate value.</p>\n\n<ul>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// keypath</span></div><div class=\"line\">vm.$watch(<span class=\"string\">'a.b.c'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// function</span></div><div class=\"line\">vm.$watch(</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + <span class=\"keyword\">this</span>.b</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// do something</span></div><div class=\"line\">  &#125;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p><code>vm.$watch</code> returns an unwatch function that stops firing the callback:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> unwatch = vm.$watch(<span class=\"string\">'a'</span>, cb)</div><div class=\"line\"><span class=\"comment\">// later, teardown the watcher</span></div><div class=\"line\">unwatch()</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Option: deep</strong></p>\n<p>To also detect nested value changes inside Objects, you need to pass in <code>deep: true</code> in the options argument. Note that you don’t need to do so to listen for Array mutations.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vm.$watch(<span class=\"string\">'someObject'</span>, callback, &#123;</div><div class=\"line\">  <span class=\"attr\">deep</span>: <span class=\"literal\">true</span></div><div class=\"line\">&#125;)</div><div class=\"line\">vm.someObject.nestedValue = <span class=\"number\">123</span></div><div class=\"line\"><span class=\"comment\">// callback is fired</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Option: immediate</strong></p>\n<p>Passing in <code>immediate: true</code> in the option will trigger the callback immediately with the current value of the expression:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vm.$watch(<span class=\"string\">'a'</span>, callback, &#123;</div><div class=\"line\">  <span class=\"attr\">immediate</span>: <span class=\"literal\">true</span></div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// callback is fired immediately with current value of `a`</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"vm-set\">vm.$set( object, key, value )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> the set value.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>This is the <strong>alias</strong> of the global <code>Vue.set</code>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#Vue-set\">Vue.set</a></p>\n</li>\n</ul>\n<h3 id=\"vm-delete\">vm.$delete( object, key )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n<li><code>{string} key</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>This is the <strong>alias</strong> of the global <code>Vue.delete</code>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#Vue-delete\">Vue.delete</a></p>\n</li>\n</ul>\n<h2 id=\"Instance-Methods-Events\"><a href=\"#Instance-Methods-Events\" class=\"headerlink\" title=\"Instance Methods / Events\"></a>Instance Methods / Events</h2><h3 id=\"vm-on\">vm.$on( event, callback )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Listen for a custom event on the current vm. Events can be triggered by <code>vm.$emit</code>. The callback will receive all the additional arguments passed into these event-triggering methods.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">vm.$on(<span class=\"string\">'test'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">msg</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(msg)</div><div class=\"line\">&#125;)</div><div class=\"line\">vm.$emit(<span class=\"string\">'test'</span>, <span class=\"string\">'hi'</span>)</div><div class=\"line\"><span class=\"comment\">// -&gt; \"hi\"</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"vm-once\">vm.$once( event, callback )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.</p>\n</li>\n</ul>\n<h3 id=\"vm-off\">vm.$off( [event, callback] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} [event]</code></li>\n<li><code>{Function} [callback]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Remove event listener(s).</p>\n<ul>\n<li><p>If no arguments are provided, remove all event listeners;</p>\n</li>\n<li><p>If only the event is provided, remove all listeners for that event;</p>\n</li>\n<li><p>If both event and callback are given, remove the listener for that specific callback only.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-emit\">vm.$emit( event, […args] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>[...args]</code></li>\n</ul>\n<p>Trigger an event on the current instance. Any additional arguments will be passed into the listener’s callback function.</p>\n</li>\n</ul>\n<h2 id=\"Instance-Methods-Lifecycle\"><a href=\"#Instance-Methods-Lifecycle\" class=\"headerlink\" title=\"Instance Methods / Lifecycle\"></a>Instance Methods / Lifecycle</h2><h3 id=\"vm-mount\">vm.$mount( [elementOrSelector] )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Element | string} [elementOrSelector]</code></li>\n<li><code>{boolean} [hydrating]</code></li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> <code>vm</code> - the instance itself</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>If a Vue instance didn’t receive the <code>el</code> option at instantiation, it will be in “unmounted” state, without an associated DOM element. <code>vm.$mount()</code> can be used to manually start the mounting of an unmounted Vue instance.</p>\n<p>If <code>elementOrSelector</code> argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.</p>\n<p>The method returns the instance itself so you can chain other instance methods after it.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> MyComponent = Vue.extend(&#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;Hello!&lt;/div&gt;'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// create and mount to #app (will replace #app)</span></div><div class=\"line\"><span class=\"keyword\">new</span> MyComponent().$mount(<span class=\"string\">'#app'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// the above is the same as:</span></div><div class=\"line\"><span class=\"keyword\">new</span> MyComponent(&#123; <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span> &#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// or, render off-document and append afterwards:</span></div><div class=\"line\"><span class=\"keyword\">var</span> component = <span class=\"keyword\">new</span> MyComponent().$mount()</div><div class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>).appendChild(component.$el)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></li>\n<li><a href=\"../guide/ssr.html\">Server-Side Rendering</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-forceUpdate\">vm.$forceUpdate()</h3>\n\n<ul>\n<li><p><strong>Usage:</strong></p>\n<p>Force the Vue instance to re-render. Note it does not affect all child components, only the instance itself and child components with inserted slot content.</p>\n</li>\n</ul>\n<h3 id=\"vm-nextTick\">vm.$nextTick( callback )</h3>\n\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update. This is the same as the global <code>Vue.nextTick</code>, except that the callback’s <code>this</code> context is automatically bound to the instance calling this method.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    example: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// modify data</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.message = <span class=\"string\">'changed'</span></div><div class=\"line\">      <span class=\"comment\">// DOM is not updated yet</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// DOM is now updated</span></div><div class=\"line\">        <span class=\"comment\">// `this` is bound to the current instance</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.doSomethingElse()</div><div class=\"line\">      &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#Vue-nextTick\">Vue.nextTick</a></li>\n<li><a href=\"../guide/reactivity.html#Async-Update-Queue\">Async Update Queue</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-destroy\">vm.$destroy()</h3>\n\n<ul>\n<li><p><strong>Usage:</strong></p>\n<p>Completely destroy a vm. Clean up its connections with other existing vms, unbind all its directives, turn off all event listeners.</p>\n<p>Triggers the <code>beforeDestroy</code> and <code>destroyed</code> hooks.</p>\n<p class=\"tip\">In normal use cases you shouldn’t have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using <code>v-if</code> and <code>v-for</code>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h2 id=\"Directives\"><a href=\"#Directives\" class=\"headerlink\" title=\"Directives\"></a>Directives</h2><h3 id=\"v-text\"><a href=\"#v-text\" class=\"headerlink\" title=\"v-text\"></a>v-text</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Updates the element’s <code>textContent</code>. If you need to update the part of <code>textContent</code>, you should use <code>{{ Mustache }}</code> interpolations.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-text</span>=<span class=\"string\">\"msg\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- same as --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/syntax.html#Text\">Data Binding Syntax - interpolations</a></p>\n</li>\n</ul>\n<h3 id=\"v-html\"><a href=\"#v-html\" class=\"headerlink\" title=\"v-html\"></a>v-html</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Updates the element’s <code>innerHTML</code>. <strong>Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates</strong>. If you find yourself trying to compose templates using <code>v-html</code>, try to rethink the solution by using components instead.</p>\n<p class=\"tip\">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">XSS attacks</a>. Only use <code>v-html</code> on trusted content and <strong>never</strong> on user-provided content.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">\"html\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/syntax.html#Raw-HTML\">Data Binding Syntax - interpolations</a></p>\n</li>\n</ul>\n<h3 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a>v-if</h3><ul>\n<li><p><strong>Expects:</strong> <code>any</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Conditionally render the element based on the truthy-ness of the expression value. The element and its contained directives / components are destroyed and re-constructed during toggles. If the element is a <code>&lt;template&gt;</code> element, its content will be extracted as the conditional block.</p>\n<p>This directive triggers transitions when its condition changes.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/conditional.html\">Conditional Rendering - v-if</a></p>\n</li>\n</ul>\n<h3 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a>v-show</h3><ul>\n<li><p><strong>Expects:</strong> <code>any</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Toggle’s the element’s <code>display</code> CSS property based on the truthy-ness of the expression value.</p>\n<p>This directive triggers transitions when its condition changes.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/conditional.html#v-show\">Conditional Rendering - v-show</a></p>\n</li>\n</ul>\n<h3 id=\"v-else\"><a href=\"#v-else\" class=\"headerlink\" title=\"v-else\"></a>v-else</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Restriction:</strong> previous sibling element must have <code>v-if</code>.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Denote the “else block” for <code>v-if</code>.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"Math.random() &gt; 0.5\"</span>&gt;</span></div><div class=\"line\">  Now you see me</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-else</span>&gt;</span></div><div class=\"line\">  Now you don't</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/conditional.html#v-else\">Conditional Rendering - v-else</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a>v-for</h3><ul>\n<li><p><strong>Expects:</strong> <code>Array | Object | number | string</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Render the element or template block multiple times based on the source data. The directive’s value must use the special syntax <code>alias in expression</code> to provide an alias for the current element being iterated on:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; item.text &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Alternatively, you can also specify an alias for the index (or the key if used on an Object):</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(item, index) in items\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(val, key) in object\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"(val, key, index) in object\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>The default behavior of <code>v-for</code> will try to patch the elements in-place without moving them. To force it to reorder elements, you need to provide an ordering hint with the <code>key</code> special attribute:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span></div><div class=\"line\">  &#123;&#123; item.text &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>The detailed usage for <code>v-for</code> is explained in the guide section linked below.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/list.html\">List Rendering</a></li>\n<li><a href=\"../guide/list.html#key\">key</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-on\"><a href=\"#v-on\" class=\"headerlink\" title=\"v-on\"></a>v-on</h3><ul>\n<li><p><strong>Shorthand:</strong> <code>@</code></p>\n</li>\n<li><p><strong>Expects:</strong> <code>Function | Inline Statement</code></p>\n</li>\n<li><p><strong>Argument:</strong> <code>event (required)</code></p>\n</li>\n<li><p><strong>Modifiers:</strong></p>\n<ul>\n<li><code>.stop</code> - call <code>event.stopPropagation()</code>.</li>\n<li><code>.prevent</code> - call <code>event.preventDefault()</code>.</li>\n<li><code>.capture</code> - add event listener in capture mode.</li>\n<li><code>.self</code> - only trigger handler if event was dispatched from this element.</li>\n<li><code>.{keyCode | keyAlias}</code> - only trigger handler on certain keys.</li>\n<li><code>.native</code> - listen for a native event on the root element of component.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Attaches an event listener to the element. The event type is denoted by the argument. The expression can either be a method name or an inline statement, or simply omitted when there are modifiers present.</p>\n<p>When used on a normal element, it listens to <strong>native DOM events</strong> only. When used on a custom element component, it also listens to <strong>custom events</strong> emitted on that child component.</p>\n<p>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special <code>$event</code> property: <code>v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;</code>.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- method handler --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- inline statement --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">\"doThat('hello', $event)\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- shorthand --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- stop propagation --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.stop</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- prevent default --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.prevent</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- prevent default without expression --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> @<span class=\"attr\">submit.prevent</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- chain modifiers --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click.stop.prevent</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- key modifier using keyAlias --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.enter</span>=<span class=\"string\">\"onEnter\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- key modifier using keyCode --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> @<span class=\"attr\">keyup.13</span>=<span class=\"string\">\"onEnter\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Listening to custom events on a child component (the handler is called when “my-event” is emitted on the child):</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> @<span class=\"attr\">my-event</span>=<span class=\"string\">\"handleThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- inline statement --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> @<span class=\"attr\">my-event</span>=<span class=\"string\">\"handleThis(123, $event)\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- native event on component --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> @<span class=\"attr\">click.native</span>=<span class=\"string\">\"onClick\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/events.html\">Methods and Event Handling</a></li>\n<li><a href=\"../guide/components.html#Custom-Events\">Components - Custom Events</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-bind\"><a href=\"#v-bind\" class=\"headerlink\" title=\"v-bind\"></a>v-bind</h3><ul>\n<li><p><strong>Shorthand:</strong> <code>:</code></p>\n</li>\n<li><p><strong>Expects:</strong> <code>any (with argument) | Object (without argument)</code></p>\n</li>\n<li><p><strong>Argument:</strong> <code>attrOrProp (optional)</code></p>\n</li>\n<li><p><strong>Modifiers:</strong></p>\n<ul>\n<li><code>.prop</code> - Used for binding DOM attributes.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Dynamically bind one or more attributes, or a component prop to an expression.</p>\n<p>When used to bind the <code>class</code> or <code>style</code> attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.</p>\n<p>When used for prop binding, the prop must be properly declared in the child component.</p>\n<p>When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode <code>class</code> and <code>style</code> does not support Array or Objects.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- bind an attribute --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">v-bind:src</span>=<span class=\"string\">\"imageSrc\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- shorthand --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">:src</span>=<span class=\"string\">\"imageSrc\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- class binding --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:class</span>=<span class=\"string\">\"&#123; red: isRed &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:class</span>=<span class=\"string\">\"[classA, classB]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:class</span>=<span class=\"string\">\"[classA, &#123; classB: isB, classC: isC &#125;]\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- style binding --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123; fontSize: size + 'px' &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"[styleObjectA, styleObjectB]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- binding an object of attributes --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind</span>=<span class=\"string\">\"&#123; id: someProp, 'other-attr': otherProp &#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- DOM attribute binding with prop modifier --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:text-content.prop</span>=<span class=\"string\">\"text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- prop binding. \"prop\" must be declared in my-component. --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">:prop</span>=<span class=\"string\">\"someThing\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- XLink --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">svg</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">:xlink:special</span>=<span class=\"string\">\"foo\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/class-and-style.html\">Class and Style Bindings</a></li>\n<li><a href=\"../guide/components.html#Props\">Components - Component Props</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a>v-model</h3><ul>\n<li><p><strong>Expects:</strong> varies based on value of form inputs element or output of components</p>\n</li>\n<li><p><strong>Limited to:</strong></p>\n<ul>\n<li><code>&lt;input&gt;</code></li>\n<li><code>&lt;select&gt;</code></li>\n<li><code>&lt;textarea&gt;</code></li>\n<li>components</li>\n</ul>\n</li>\n<li><p><strong>Modifiers:</strong></p>\n<ul>\n<li><a href=\"../guide/forms.html#lazy\"><code>.lazy</code></a> - listen to <code>change</code> events instead of <code>input</code></li>\n<li><a href=\"../guide/forms.html#number\"><code>.number</code></a> - cast input string to numbers</li>\n<li><a href=\"/guild/forms.html#trim\"><code>.trim</code></a> - trim input</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Create a two-way binding on a form input element or a component. For detailed usage, see guide section linked below.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/forms.html\">Form Input Bindings</a></li>\n<li><a href=\"../guide/components.html#Form-Input-Components-using-Custom-Events\">Components - Form Input Components using Custom Events</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-pre\"><a href=\"#v-pre\" class=\"headerlink\" title=\"v-pre\"></a>v-pre</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-pre</span>&gt;</span>&#123;&#123; this will not be compiled &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"v-cloak\"><a href=\"#v-cloak\" class=\"headerlink\" title=\"v-cloak\"></a>v-cloak</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as <code>[v-cloak] { display: none }</code>, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-attr\">[v-cloak]</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: none;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-cloak</span>&gt;</span></div><div class=\"line\">  &#123;&#123; message &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>The <code>&lt;div&gt;</code> will not be visible until the compilation is done.</p>\n</li>\n</ul>\n<h3 id=\"v-once\"><a href=\"#v-once\" class=\"headerlink\" title=\"v-once\"></a>v-once</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Render the element and component <strong>once</strong> only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- single element --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-once</span>&gt;</span>This will never change: &#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- the element have children --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-once</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>comment<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- component --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-once</span> <span class=\"attr\">:comment</span>=<span class=\"string\">\"msg\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- v-for directive --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"i in list\"</span> <span class=\"attr\">v-once</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/syntax.html#Text\">Data Binding Syntax - interpolations</a></li>\n<li><a href=\"../guide/components.html#Cheap-Static-Components-with-v-once\">Components - Cheap Static Components with v-once</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Special-Attributes\"><a href=\"#Special-Attributes\" class=\"headerlink\" title=\"Special Attributes\"></a>Special Attributes</h2><h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n<p>The <code>key</code> special attribute is primarily used as a hint for Vue’s virtual DOM algorithm to identify VNodes when diffing the new list of nodes against the old list. Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed/destroyed.</p>\n<p>Children of the same common parent must have <strong>unique keys</strong>. Duplicate keys will cause render errors.</p>\n<p>The most common use case is combined with <code>v-for</code>:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:</p>\n<ul>\n<li>Properly trigger lifecycle hooks of a component</li>\n<li>Trigger transitions</li>\n</ul>\n<p>For example:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"text\"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>When <code>text</code> changes, the <code>&lt;span&gt;</code> will always be replaced instead of patched, so a transition will be triggered.</p>\n</li>\n</ul>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n<p><code>ref</code> is used to register a reference to an element or a child component. The reference will be registered under the parent component’s <code>$refs</code> object. If used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be component instance:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- vm.$refs.p will the DOM node --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"p\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- vm.$refs.child will be the child comp instance --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child-comp</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"child\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child-comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>When used on elements/components with <code>v-for</code>, the registered reference will be an Array containing DOM nodes or component instances.</p>\n<p>An important note about the ref registration timing: because the refs themselves are created as a result of the render function, you cannot access them on the initial render - they don’t exist yet! <code>$refs</code> is also non-reactive, therefore you should not attempt to use it in templates for data-binding.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Child-Component-Refs\">Child Component Refs</a></p>\n</li>\n</ul>\n<h3 id=\"slot\"><a href=\"#slot\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n<p>Used on content inserted into child components to indicate which named slot the content belongs to.</p>\n<p>For detailed usage, see the guide section linked below.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Named-Slots\">Named Slots</a></p>\n</li>\n</ul>\n<h2 id=\"Built-In-Components\"><a href=\"#Built-In-Components\" class=\"headerlink\" title=\"Built-In Components\"></a>Built-In Components</h2><h3 id=\"component\"><a href=\"#component\" class=\"headerlink\" title=\"component\"></a>component</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>is</code> - string | ComponentDefinition | ComponentConstructor</li>\n<li><code>inline-template</code> - boolean</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>A “meta component” for rendering dynamic components. The actual component to render is determined by the <code>is</code> prop:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- a dynamic component controlled by --&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- the `componentId` property on the vm --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"componentId\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- can also render registered component or component passed as prop --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"$options.components.child\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Dynamic-Components\">Dynamic Components</a></p>\n</li>\n</ul>\n<h3 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>name</code> - string, Used to automatically generate transition CSS class names. e.g. <code>name: &#39;fade&#39;</code> will auto expand to <code>.fade-enter</code>, <code>.fade-enter-active</code>, etc. Defaults to <code>&quot;v&quot;</code>.</li>\n<li><code>appear</code> - boolean, Whether to apply transition on initial render. Defaults to <code>false</code>.</li>\n<li><code>css</code> - boolean, Whether to apply CSS transition classes. Defaults to <code>true</code>. If set to <code>false</code>, will only trigger JavaScript hooks registered via component events.</li>\n<li><code>type</code> - string, Specify the type of transition events to wait for to determine transition end timing. Available values are <code>&quot;transition&quot;</code> and <code>&quot;animation&quot;</code>. By default, it will automatically detect the type that has a longer duration.</li>\n<li><code>mode</code> - string, Controls the timing sequence of leaving/entering transitions. Available modes are <code>&quot;out-in&quot;</code> and <code>&quot;in-out&quot;</code>; defaults to simultaneous.</li>\n<li><code>enter-class</code> - string</li>\n<li><code>leave-class</code> - string</li>\n<li><code>enter-active-class</code> - string</li>\n<li><code>leave-active-class</code> - string</li>\n<li><code>appear-class</code> - string</li>\n<li><code>appear-active-class</code> - string</li>\n</ul>\n</li>\n<li><p><strong>Events:</strong></p>\n<ul>\n<li><code>before-enter</code></li>\n<li><code>enter</code></li>\n<li><code>after-enter</code></li>\n<li><code>before-leave</code></li>\n<li><code>leave</code></li>\n<li><code>after-leave</code></li>\n<li><code>before-appear</code></li>\n<li><code>appear</code></li>\n<li><code>after-appear</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p><code>&lt;transition&gt;</code> serve as transition effects for <strong>single</strong> element/component. The <code>&lt;transition&gt;</code> does not render an extra DOM element, nor does it show up in the inspected component hierarchy. It simply applies the transition behavior to the wrapped content inside.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- simple element --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"ok\"</span>&gt;</span>toggled content<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- dynamic component --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fade\"</span> <span class=\"attr\">mode</span>=<span class=\"string\">\"out-in\"</span> <span class=\"attr\">appear</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- event hooking --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transition-demo\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span> @<span class=\"attr\">after-enter</span>=<span class=\"string\">\"transitionComplete\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"ok\"</span>&gt;</span>toggled content<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    <span class=\"attr\">transitionComplete</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// for passed 'el' that DOM element as the argument, something ...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;).$mount(<span class=\"string\">'#transition-demo'</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/transitions.html\">Transitions: Entering, Leaving, and Lists</a></p>\n</li>\n</ul>\n<h3 id=\"transition-group\"><a href=\"#transition-group\" class=\"headerlink\" title=\"transition-group\"></a>transition-group</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>tag</code> - string, defaults to <code>span</code>.</li>\n<li><code>move-class</code> - overwrite CSS class applied during moving transition.</li>\n<li>exposes the same props as <code>&lt;transition&gt;</code> except <code>mode</code>.</li>\n</ul>\n</li>\n<li><p><strong>Events:</strong></p>\n<ul>\n<li>exposes the same events as <code>&lt;transition&gt;</code>.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p><code>&lt;transition-group&gt;</code> serve as transition effects for <strong>multiple</strong> elements/components. The <code>&lt;transition-group&gt;</code> renders a real DOM element. By default it renders a <code>&lt;span&gt;</code>, and you can configure what element is should render via the <code>tag</code> attribute.</p>\n<p>Note every child in a <code>&lt;transition-group&gt;</code> must be <strong>uniquely keyed</strong> for the animations to work properly.</p>\n<p><code>&lt;transition-group&gt;</code> supports moving transitions via CSS transform. When a child’s position on screen has changed after an updated, it will get applied a moving CSS class (auto generated from the <code>name</code> attribute or configured with the <code>move-class</code> attribute). If the CSS <code>transform</code> property is “transition-able” when the moving class is applied, the element will be smoothly animated to its destination using the <a href=\"https://aerotwist.com/blog/flip-your-animations/\">FLIP technique</a>.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition-group</span> <span class=\"attr\">tag</span>=<span class=\"string\">\"ul\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"slide\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">:key</span>=<span class=\"string\">\"item.id\"</span>&gt;</span></div><div class=\"line\">    &#123;&#123; item.text &#125;&#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/transitions.html\">Transitions: Entering, Leaving, and Lists</a></p>\n</li>\n</ul>\n<h3 id=\"keep-alive\"><a href=\"#keep-alive\" class=\"headerlink\" title=\"keep-alive\"></a>keep-alive</h3><ul>\n<li><p><strong>Usage:</strong></p>\n<p>When wrapped around a dynamic component, <code>&lt;keep-alive&gt;</code> caches the inactive component instances without destroying them. Similar to <code>&lt;transition&gt;</code>, <code>&lt;keep-alive&gt;</code> is an abstract component: it doesn’t render a DOM element itself, and doesn’t show up in the component parent chain.</p>\n<p>When a component is toggled inside <code>&lt;keep-alive&gt;</code>, its <code>activated</code> and <code>deactivated</code> lifecycle hooks will be invoked accordingly.</p>\n<p>Primarily used with preserve component state or avoid re-rendering.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- basic --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- multiple conditional children --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">comp-a</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"a &gt; 1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp-a</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">comp-b</span> <span class=\"attr\">v-else</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp-b</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">&lt;!-- used together with &lt;transition&gt; --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:is</span>=<span class=\"string\">\"view\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure>\n<p class=\"tip\"><code>&lt;keep-alive&gt;</code> does not work with functional components because they do not have instances to be cached.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#keep-alive\">Dynamic Components - keep-alive</a></p>\n</li>\n</ul>\n<h3 id=\"slot-1\"><a href=\"#slot-1\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>name</code> - string, Used for named slot.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p><code>&lt;slot&gt;</code> serve as content distribution outlets in component templates. <code>&lt;slot&gt;</code> itself will be replaced.</p>\n<p>For detailed usage, see the guide section linked below.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Content-Distribution-with-Slots\">Content Distribution with Slots</a></p>\n</li>\n</ul>\n<h2 id=\"VNode-Interface\"><a href=\"#VNode-Interface\" class=\"headerlink\" title=\"VNode Interface\"></a>VNode Interface</h2><ul>\n<li>Please refer to the <a href=\"https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js\">VNode class declaration</a>.</li>\n</ul>\n<h2 id=\"Server-Side-Rendering\"><a href=\"#Server-Side-Rendering\" class=\"headerlink\" title=\"Server-Side Rendering\"></a>Server-Side Rendering</h2><ul>\n<li>Please refer to the <a href=\"https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer\">vue-server-renderer package documentation</a>.<br>–&gt;</li>\n</ul>\n"}],"Post":[{"title":"Zman 1.0.0 Released","date":"2015-10-26T14:00:00.000Z","_content":"\n","source":"_posts/1.0.0-release.md","raw":"---\ntitle: Zman 1.0.0 Released\ndate: 2015-10-26 10:00:00\n---\n\n","slug":"1.0.0-release","published":1,"updated":"2016-11-07T22:23:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civ8ndozg0001wqm1xmxac78p","content":"","excerpt":"","more":""}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}